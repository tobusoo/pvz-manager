// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mock

//go:generate minimock -i gitlab.ozon.dev/chppppr/homework/internal/app/manager_service.Usecases -o usecases_mock.go -n UsecasesMock -p mock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.ozon.dev/chppppr/homework/internal/domain"
	"gitlab.ozon.dev/chppppr/homework/internal/dto"
)

// UsecasesMock implements mm_manager_service.Usecases
type UsecasesMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAcceptOrder          func(req *dto.AddOrderRequest) (err error)
	funcAcceptOrderOrigin    string
	inspectFuncAcceptOrder   func(req *dto.AddOrderRequest)
	afterAcceptOrderCounter  uint64
	beforeAcceptOrderCounter uint64
	AcceptOrderMock          mUsecasesMockAcceptOrder

	funcAcceptRefund          func(req *dto.RefundRequest) (err error)
	funcAcceptRefundOrigin    string
	inspectFuncAcceptRefund   func(req *dto.RefundRequest)
	afterAcceptRefundCounter  uint64
	beforeAcceptRefundCounter uint64
	AcceptRefundMock          mUsecasesMockAcceptRefund

	funcGetOrders          func(req *dto.ViewOrdersRequest) (oa1 []domain.OrderView, err error)
	funcGetOrdersOrigin    string
	inspectFuncGetOrders   func(req *dto.ViewOrdersRequest)
	afterGetOrdersCounter  uint64
	beforeGetOrdersCounter uint64
	GetOrdersMock          mUsecasesMockGetOrders

	funcGetRefunds          func(req *dto.ViewRefundsRequest) (oa1 []domain.OrderView, err error)
	funcGetRefundsOrigin    string
	inspectFuncGetRefunds   func(req *dto.ViewRefundsRequest)
	afterGetRefundsCounter  uint64
	beforeGetRefundsCounter uint64
	GetRefundsMock          mUsecasesMockGetRefunds

	funcGive          func(req *dto.GiveOrdersRequest) (ea1 []error)
	funcGiveOrigin    string
	inspectFuncGive   func(req *dto.GiveOrdersRequest)
	afterGiveCounter  uint64
	beforeGiveCounter uint64
	GiveMock          mUsecasesMockGive

	funcReturn          func(req *dto.ReturnRequest) (err error)
	funcReturnOrigin    string
	inspectFuncReturn   func(req *dto.ReturnRequest)
	afterReturnCounter  uint64
	beforeReturnCounter uint64
	ReturnMock          mUsecasesMockReturn
}

// NewUsecasesMock returns a mock for mm_manager_service.Usecases
func NewUsecasesMock(t minimock.Tester) *UsecasesMock {
	m := &UsecasesMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AcceptOrderMock = mUsecasesMockAcceptOrder{mock: m}
	m.AcceptOrderMock.callArgs = []*UsecasesMockAcceptOrderParams{}

	m.AcceptRefundMock = mUsecasesMockAcceptRefund{mock: m}
	m.AcceptRefundMock.callArgs = []*UsecasesMockAcceptRefundParams{}

	m.GetOrdersMock = mUsecasesMockGetOrders{mock: m}
	m.GetOrdersMock.callArgs = []*UsecasesMockGetOrdersParams{}

	m.GetRefundsMock = mUsecasesMockGetRefunds{mock: m}
	m.GetRefundsMock.callArgs = []*UsecasesMockGetRefundsParams{}

	m.GiveMock = mUsecasesMockGive{mock: m}
	m.GiveMock.callArgs = []*UsecasesMockGiveParams{}

	m.ReturnMock = mUsecasesMockReturn{mock: m}
	m.ReturnMock.callArgs = []*UsecasesMockReturnParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mUsecasesMockAcceptOrder struct {
	optional           bool
	mock               *UsecasesMock
	defaultExpectation *UsecasesMockAcceptOrderExpectation
	expectations       []*UsecasesMockAcceptOrderExpectation

	callArgs []*UsecasesMockAcceptOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UsecasesMockAcceptOrderExpectation specifies expectation struct of the Usecases.AcceptOrder
type UsecasesMockAcceptOrderExpectation struct {
	mock               *UsecasesMock
	params             *UsecasesMockAcceptOrderParams
	paramPtrs          *UsecasesMockAcceptOrderParamPtrs
	expectationOrigins UsecasesMockAcceptOrderExpectationOrigins
	results            *UsecasesMockAcceptOrderResults
	returnOrigin       string
	Counter            uint64
}

// UsecasesMockAcceptOrderParams contains parameters of the Usecases.AcceptOrder
type UsecasesMockAcceptOrderParams struct {
	req *dto.AddOrderRequest
}

// UsecasesMockAcceptOrderParamPtrs contains pointers to parameters of the Usecases.AcceptOrder
type UsecasesMockAcceptOrderParamPtrs struct {
	req **dto.AddOrderRequest
}

// UsecasesMockAcceptOrderResults contains results of the Usecases.AcceptOrder
type UsecasesMockAcceptOrderResults struct {
	err error
}

// UsecasesMockAcceptOrderOrigins contains origins of expectations of the Usecases.AcceptOrder
type UsecasesMockAcceptOrderExpectationOrigins struct {
	origin    string
	originReq string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAcceptOrder *mUsecasesMockAcceptOrder) Optional() *mUsecasesMockAcceptOrder {
	mmAcceptOrder.optional = true
	return mmAcceptOrder
}

// Expect sets up expected params for Usecases.AcceptOrder
func (mmAcceptOrder *mUsecasesMockAcceptOrder) Expect(req *dto.AddOrderRequest) *mUsecasesMockAcceptOrder {
	if mmAcceptOrder.mock.funcAcceptOrder != nil {
		mmAcceptOrder.mock.t.Fatalf("UsecasesMock.AcceptOrder mock is already set by Set")
	}

	if mmAcceptOrder.defaultExpectation == nil {
		mmAcceptOrder.defaultExpectation = &UsecasesMockAcceptOrderExpectation{}
	}

	if mmAcceptOrder.defaultExpectation.paramPtrs != nil {
		mmAcceptOrder.mock.t.Fatalf("UsecasesMock.AcceptOrder mock is already set by ExpectParams functions")
	}

	mmAcceptOrder.defaultExpectation.params = &UsecasesMockAcceptOrderParams{req}
	mmAcceptOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAcceptOrder.expectations {
		if minimock.Equal(e.params, mmAcceptOrder.defaultExpectation.params) {
			mmAcceptOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAcceptOrder.defaultExpectation.params)
		}
	}

	return mmAcceptOrder
}

// ExpectReqParam1 sets up expected param req for Usecases.AcceptOrder
func (mmAcceptOrder *mUsecasesMockAcceptOrder) ExpectReqParam1(req *dto.AddOrderRequest) *mUsecasesMockAcceptOrder {
	if mmAcceptOrder.mock.funcAcceptOrder != nil {
		mmAcceptOrder.mock.t.Fatalf("UsecasesMock.AcceptOrder mock is already set by Set")
	}

	if mmAcceptOrder.defaultExpectation == nil {
		mmAcceptOrder.defaultExpectation = &UsecasesMockAcceptOrderExpectation{}
	}

	if mmAcceptOrder.defaultExpectation.params != nil {
		mmAcceptOrder.mock.t.Fatalf("UsecasesMock.AcceptOrder mock is already set by Expect")
	}

	if mmAcceptOrder.defaultExpectation.paramPtrs == nil {
		mmAcceptOrder.defaultExpectation.paramPtrs = &UsecasesMockAcceptOrderParamPtrs{}
	}
	mmAcceptOrder.defaultExpectation.paramPtrs.req = &req
	mmAcceptOrder.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmAcceptOrder
}

// Inspect accepts an inspector function that has same arguments as the Usecases.AcceptOrder
func (mmAcceptOrder *mUsecasesMockAcceptOrder) Inspect(f func(req *dto.AddOrderRequest)) *mUsecasesMockAcceptOrder {
	if mmAcceptOrder.mock.inspectFuncAcceptOrder != nil {
		mmAcceptOrder.mock.t.Fatalf("Inspect function is already set for UsecasesMock.AcceptOrder")
	}

	mmAcceptOrder.mock.inspectFuncAcceptOrder = f

	return mmAcceptOrder
}

// Return sets up results that will be returned by Usecases.AcceptOrder
func (mmAcceptOrder *mUsecasesMockAcceptOrder) Return(err error) *UsecasesMock {
	if mmAcceptOrder.mock.funcAcceptOrder != nil {
		mmAcceptOrder.mock.t.Fatalf("UsecasesMock.AcceptOrder mock is already set by Set")
	}

	if mmAcceptOrder.defaultExpectation == nil {
		mmAcceptOrder.defaultExpectation = &UsecasesMockAcceptOrderExpectation{mock: mmAcceptOrder.mock}
	}
	mmAcceptOrder.defaultExpectation.results = &UsecasesMockAcceptOrderResults{err}
	mmAcceptOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAcceptOrder.mock
}

// Set uses given function f to mock the Usecases.AcceptOrder method
func (mmAcceptOrder *mUsecasesMockAcceptOrder) Set(f func(req *dto.AddOrderRequest) (err error)) *UsecasesMock {
	if mmAcceptOrder.defaultExpectation != nil {
		mmAcceptOrder.mock.t.Fatalf("Default expectation is already set for the Usecases.AcceptOrder method")
	}

	if len(mmAcceptOrder.expectations) > 0 {
		mmAcceptOrder.mock.t.Fatalf("Some expectations are already set for the Usecases.AcceptOrder method")
	}

	mmAcceptOrder.mock.funcAcceptOrder = f
	mmAcceptOrder.mock.funcAcceptOrderOrigin = minimock.CallerInfo(1)
	return mmAcceptOrder.mock
}

// When sets expectation for the Usecases.AcceptOrder which will trigger the result defined by the following
// Then helper
func (mmAcceptOrder *mUsecasesMockAcceptOrder) When(req *dto.AddOrderRequest) *UsecasesMockAcceptOrderExpectation {
	if mmAcceptOrder.mock.funcAcceptOrder != nil {
		mmAcceptOrder.mock.t.Fatalf("UsecasesMock.AcceptOrder mock is already set by Set")
	}

	expectation := &UsecasesMockAcceptOrderExpectation{
		mock:               mmAcceptOrder.mock,
		params:             &UsecasesMockAcceptOrderParams{req},
		expectationOrigins: UsecasesMockAcceptOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAcceptOrder.expectations = append(mmAcceptOrder.expectations, expectation)
	return expectation
}

// Then sets up Usecases.AcceptOrder return parameters for the expectation previously defined by the When method
func (e *UsecasesMockAcceptOrderExpectation) Then(err error) *UsecasesMock {
	e.results = &UsecasesMockAcceptOrderResults{err}
	return e.mock
}

// Times sets number of times Usecases.AcceptOrder should be invoked
func (mmAcceptOrder *mUsecasesMockAcceptOrder) Times(n uint64) *mUsecasesMockAcceptOrder {
	if n == 0 {
		mmAcceptOrder.mock.t.Fatalf("Times of UsecasesMock.AcceptOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAcceptOrder.expectedInvocations, n)
	mmAcceptOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAcceptOrder
}

func (mmAcceptOrder *mUsecasesMockAcceptOrder) invocationsDone() bool {
	if len(mmAcceptOrder.expectations) == 0 && mmAcceptOrder.defaultExpectation == nil && mmAcceptOrder.mock.funcAcceptOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAcceptOrder.mock.afterAcceptOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAcceptOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AcceptOrder implements mm_manager_service.Usecases
func (mmAcceptOrder *UsecasesMock) AcceptOrder(req *dto.AddOrderRequest) (err error) {
	mm_atomic.AddUint64(&mmAcceptOrder.beforeAcceptOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmAcceptOrder.afterAcceptOrderCounter, 1)

	mmAcceptOrder.t.Helper()

	if mmAcceptOrder.inspectFuncAcceptOrder != nil {
		mmAcceptOrder.inspectFuncAcceptOrder(req)
	}

	mm_params := UsecasesMockAcceptOrderParams{req}

	// Record call args
	mmAcceptOrder.AcceptOrderMock.mutex.Lock()
	mmAcceptOrder.AcceptOrderMock.callArgs = append(mmAcceptOrder.AcceptOrderMock.callArgs, &mm_params)
	mmAcceptOrder.AcceptOrderMock.mutex.Unlock()

	for _, e := range mmAcceptOrder.AcceptOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAcceptOrder.AcceptOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAcceptOrder.AcceptOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmAcceptOrder.AcceptOrderMock.defaultExpectation.params
		mm_want_ptrs := mmAcceptOrder.AcceptOrderMock.defaultExpectation.paramPtrs

		mm_got := UsecasesMockAcceptOrderParams{req}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmAcceptOrder.t.Errorf("UsecasesMock.AcceptOrder got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAcceptOrder.AcceptOrderMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAcceptOrder.t.Errorf("UsecasesMock.AcceptOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAcceptOrder.AcceptOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAcceptOrder.AcceptOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmAcceptOrder.t.Fatal("No results are set for the UsecasesMock.AcceptOrder")
		}
		return (*mm_results).err
	}
	if mmAcceptOrder.funcAcceptOrder != nil {
		return mmAcceptOrder.funcAcceptOrder(req)
	}
	mmAcceptOrder.t.Fatalf("Unexpected call to UsecasesMock.AcceptOrder. %v", req)
	return
}

// AcceptOrderAfterCounter returns a count of finished UsecasesMock.AcceptOrder invocations
func (mmAcceptOrder *UsecasesMock) AcceptOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcceptOrder.afterAcceptOrderCounter)
}

// AcceptOrderBeforeCounter returns a count of UsecasesMock.AcceptOrder invocations
func (mmAcceptOrder *UsecasesMock) AcceptOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcceptOrder.beforeAcceptOrderCounter)
}

// Calls returns a list of arguments used in each call to UsecasesMock.AcceptOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAcceptOrder *mUsecasesMockAcceptOrder) Calls() []*UsecasesMockAcceptOrderParams {
	mmAcceptOrder.mutex.RLock()

	argCopy := make([]*UsecasesMockAcceptOrderParams, len(mmAcceptOrder.callArgs))
	copy(argCopy, mmAcceptOrder.callArgs)

	mmAcceptOrder.mutex.RUnlock()

	return argCopy
}

// MinimockAcceptOrderDone returns true if the count of the AcceptOrder invocations corresponds
// the number of defined expectations
func (m *UsecasesMock) MinimockAcceptOrderDone() bool {
	if m.AcceptOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AcceptOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AcceptOrderMock.invocationsDone()
}

// MinimockAcceptOrderInspect logs each unmet expectation
func (m *UsecasesMock) MinimockAcceptOrderInspect() {
	for _, e := range m.AcceptOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UsecasesMock.AcceptOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAcceptOrderCounter := mm_atomic.LoadUint64(&m.afterAcceptOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AcceptOrderMock.defaultExpectation != nil && afterAcceptOrderCounter < 1 {
		if m.AcceptOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UsecasesMock.AcceptOrder at\n%s", m.AcceptOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UsecasesMock.AcceptOrder at\n%s with params: %#v", m.AcceptOrderMock.defaultExpectation.expectationOrigins.origin, *m.AcceptOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcceptOrder != nil && afterAcceptOrderCounter < 1 {
		m.t.Errorf("Expected call to UsecasesMock.AcceptOrder at\n%s", m.funcAcceptOrderOrigin)
	}

	if !m.AcceptOrderMock.invocationsDone() && afterAcceptOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to UsecasesMock.AcceptOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AcceptOrderMock.expectedInvocations), m.AcceptOrderMock.expectedInvocationsOrigin, afterAcceptOrderCounter)
	}
}

type mUsecasesMockAcceptRefund struct {
	optional           bool
	mock               *UsecasesMock
	defaultExpectation *UsecasesMockAcceptRefundExpectation
	expectations       []*UsecasesMockAcceptRefundExpectation

	callArgs []*UsecasesMockAcceptRefundParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UsecasesMockAcceptRefundExpectation specifies expectation struct of the Usecases.AcceptRefund
type UsecasesMockAcceptRefundExpectation struct {
	mock               *UsecasesMock
	params             *UsecasesMockAcceptRefundParams
	paramPtrs          *UsecasesMockAcceptRefundParamPtrs
	expectationOrigins UsecasesMockAcceptRefundExpectationOrigins
	results            *UsecasesMockAcceptRefundResults
	returnOrigin       string
	Counter            uint64
}

// UsecasesMockAcceptRefundParams contains parameters of the Usecases.AcceptRefund
type UsecasesMockAcceptRefundParams struct {
	req *dto.RefundRequest
}

// UsecasesMockAcceptRefundParamPtrs contains pointers to parameters of the Usecases.AcceptRefund
type UsecasesMockAcceptRefundParamPtrs struct {
	req **dto.RefundRequest
}

// UsecasesMockAcceptRefundResults contains results of the Usecases.AcceptRefund
type UsecasesMockAcceptRefundResults struct {
	err error
}

// UsecasesMockAcceptRefundOrigins contains origins of expectations of the Usecases.AcceptRefund
type UsecasesMockAcceptRefundExpectationOrigins struct {
	origin    string
	originReq string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAcceptRefund *mUsecasesMockAcceptRefund) Optional() *mUsecasesMockAcceptRefund {
	mmAcceptRefund.optional = true
	return mmAcceptRefund
}

// Expect sets up expected params for Usecases.AcceptRefund
func (mmAcceptRefund *mUsecasesMockAcceptRefund) Expect(req *dto.RefundRequest) *mUsecasesMockAcceptRefund {
	if mmAcceptRefund.mock.funcAcceptRefund != nil {
		mmAcceptRefund.mock.t.Fatalf("UsecasesMock.AcceptRefund mock is already set by Set")
	}

	if mmAcceptRefund.defaultExpectation == nil {
		mmAcceptRefund.defaultExpectation = &UsecasesMockAcceptRefundExpectation{}
	}

	if mmAcceptRefund.defaultExpectation.paramPtrs != nil {
		mmAcceptRefund.mock.t.Fatalf("UsecasesMock.AcceptRefund mock is already set by ExpectParams functions")
	}

	mmAcceptRefund.defaultExpectation.params = &UsecasesMockAcceptRefundParams{req}
	mmAcceptRefund.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAcceptRefund.expectations {
		if minimock.Equal(e.params, mmAcceptRefund.defaultExpectation.params) {
			mmAcceptRefund.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAcceptRefund.defaultExpectation.params)
		}
	}

	return mmAcceptRefund
}

// ExpectReqParam1 sets up expected param req for Usecases.AcceptRefund
func (mmAcceptRefund *mUsecasesMockAcceptRefund) ExpectReqParam1(req *dto.RefundRequest) *mUsecasesMockAcceptRefund {
	if mmAcceptRefund.mock.funcAcceptRefund != nil {
		mmAcceptRefund.mock.t.Fatalf("UsecasesMock.AcceptRefund mock is already set by Set")
	}

	if mmAcceptRefund.defaultExpectation == nil {
		mmAcceptRefund.defaultExpectation = &UsecasesMockAcceptRefundExpectation{}
	}

	if mmAcceptRefund.defaultExpectation.params != nil {
		mmAcceptRefund.mock.t.Fatalf("UsecasesMock.AcceptRefund mock is already set by Expect")
	}

	if mmAcceptRefund.defaultExpectation.paramPtrs == nil {
		mmAcceptRefund.defaultExpectation.paramPtrs = &UsecasesMockAcceptRefundParamPtrs{}
	}
	mmAcceptRefund.defaultExpectation.paramPtrs.req = &req
	mmAcceptRefund.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmAcceptRefund
}

// Inspect accepts an inspector function that has same arguments as the Usecases.AcceptRefund
func (mmAcceptRefund *mUsecasesMockAcceptRefund) Inspect(f func(req *dto.RefundRequest)) *mUsecasesMockAcceptRefund {
	if mmAcceptRefund.mock.inspectFuncAcceptRefund != nil {
		mmAcceptRefund.mock.t.Fatalf("Inspect function is already set for UsecasesMock.AcceptRefund")
	}

	mmAcceptRefund.mock.inspectFuncAcceptRefund = f

	return mmAcceptRefund
}

// Return sets up results that will be returned by Usecases.AcceptRefund
func (mmAcceptRefund *mUsecasesMockAcceptRefund) Return(err error) *UsecasesMock {
	if mmAcceptRefund.mock.funcAcceptRefund != nil {
		mmAcceptRefund.mock.t.Fatalf("UsecasesMock.AcceptRefund mock is already set by Set")
	}

	if mmAcceptRefund.defaultExpectation == nil {
		mmAcceptRefund.defaultExpectation = &UsecasesMockAcceptRefundExpectation{mock: mmAcceptRefund.mock}
	}
	mmAcceptRefund.defaultExpectation.results = &UsecasesMockAcceptRefundResults{err}
	mmAcceptRefund.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAcceptRefund.mock
}

// Set uses given function f to mock the Usecases.AcceptRefund method
func (mmAcceptRefund *mUsecasesMockAcceptRefund) Set(f func(req *dto.RefundRequest) (err error)) *UsecasesMock {
	if mmAcceptRefund.defaultExpectation != nil {
		mmAcceptRefund.mock.t.Fatalf("Default expectation is already set for the Usecases.AcceptRefund method")
	}

	if len(mmAcceptRefund.expectations) > 0 {
		mmAcceptRefund.mock.t.Fatalf("Some expectations are already set for the Usecases.AcceptRefund method")
	}

	mmAcceptRefund.mock.funcAcceptRefund = f
	mmAcceptRefund.mock.funcAcceptRefundOrigin = minimock.CallerInfo(1)
	return mmAcceptRefund.mock
}

// When sets expectation for the Usecases.AcceptRefund which will trigger the result defined by the following
// Then helper
func (mmAcceptRefund *mUsecasesMockAcceptRefund) When(req *dto.RefundRequest) *UsecasesMockAcceptRefundExpectation {
	if mmAcceptRefund.mock.funcAcceptRefund != nil {
		mmAcceptRefund.mock.t.Fatalf("UsecasesMock.AcceptRefund mock is already set by Set")
	}

	expectation := &UsecasesMockAcceptRefundExpectation{
		mock:               mmAcceptRefund.mock,
		params:             &UsecasesMockAcceptRefundParams{req},
		expectationOrigins: UsecasesMockAcceptRefundExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAcceptRefund.expectations = append(mmAcceptRefund.expectations, expectation)
	return expectation
}

// Then sets up Usecases.AcceptRefund return parameters for the expectation previously defined by the When method
func (e *UsecasesMockAcceptRefundExpectation) Then(err error) *UsecasesMock {
	e.results = &UsecasesMockAcceptRefundResults{err}
	return e.mock
}

// Times sets number of times Usecases.AcceptRefund should be invoked
func (mmAcceptRefund *mUsecasesMockAcceptRefund) Times(n uint64) *mUsecasesMockAcceptRefund {
	if n == 0 {
		mmAcceptRefund.mock.t.Fatalf("Times of UsecasesMock.AcceptRefund mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAcceptRefund.expectedInvocations, n)
	mmAcceptRefund.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAcceptRefund
}

func (mmAcceptRefund *mUsecasesMockAcceptRefund) invocationsDone() bool {
	if len(mmAcceptRefund.expectations) == 0 && mmAcceptRefund.defaultExpectation == nil && mmAcceptRefund.mock.funcAcceptRefund == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAcceptRefund.mock.afterAcceptRefundCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAcceptRefund.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AcceptRefund implements mm_manager_service.Usecases
func (mmAcceptRefund *UsecasesMock) AcceptRefund(req *dto.RefundRequest) (err error) {
	mm_atomic.AddUint64(&mmAcceptRefund.beforeAcceptRefundCounter, 1)
	defer mm_atomic.AddUint64(&mmAcceptRefund.afterAcceptRefundCounter, 1)

	mmAcceptRefund.t.Helper()

	if mmAcceptRefund.inspectFuncAcceptRefund != nil {
		mmAcceptRefund.inspectFuncAcceptRefund(req)
	}

	mm_params := UsecasesMockAcceptRefundParams{req}

	// Record call args
	mmAcceptRefund.AcceptRefundMock.mutex.Lock()
	mmAcceptRefund.AcceptRefundMock.callArgs = append(mmAcceptRefund.AcceptRefundMock.callArgs, &mm_params)
	mmAcceptRefund.AcceptRefundMock.mutex.Unlock()

	for _, e := range mmAcceptRefund.AcceptRefundMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAcceptRefund.AcceptRefundMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAcceptRefund.AcceptRefundMock.defaultExpectation.Counter, 1)
		mm_want := mmAcceptRefund.AcceptRefundMock.defaultExpectation.params
		mm_want_ptrs := mmAcceptRefund.AcceptRefundMock.defaultExpectation.paramPtrs

		mm_got := UsecasesMockAcceptRefundParams{req}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmAcceptRefund.t.Errorf("UsecasesMock.AcceptRefund got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAcceptRefund.AcceptRefundMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAcceptRefund.t.Errorf("UsecasesMock.AcceptRefund got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAcceptRefund.AcceptRefundMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAcceptRefund.AcceptRefundMock.defaultExpectation.results
		if mm_results == nil {
			mmAcceptRefund.t.Fatal("No results are set for the UsecasesMock.AcceptRefund")
		}
		return (*mm_results).err
	}
	if mmAcceptRefund.funcAcceptRefund != nil {
		return mmAcceptRefund.funcAcceptRefund(req)
	}
	mmAcceptRefund.t.Fatalf("Unexpected call to UsecasesMock.AcceptRefund. %v", req)
	return
}

// AcceptRefundAfterCounter returns a count of finished UsecasesMock.AcceptRefund invocations
func (mmAcceptRefund *UsecasesMock) AcceptRefundAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcceptRefund.afterAcceptRefundCounter)
}

// AcceptRefundBeforeCounter returns a count of UsecasesMock.AcceptRefund invocations
func (mmAcceptRefund *UsecasesMock) AcceptRefundBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAcceptRefund.beforeAcceptRefundCounter)
}

// Calls returns a list of arguments used in each call to UsecasesMock.AcceptRefund.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAcceptRefund *mUsecasesMockAcceptRefund) Calls() []*UsecasesMockAcceptRefundParams {
	mmAcceptRefund.mutex.RLock()

	argCopy := make([]*UsecasesMockAcceptRefundParams, len(mmAcceptRefund.callArgs))
	copy(argCopy, mmAcceptRefund.callArgs)

	mmAcceptRefund.mutex.RUnlock()

	return argCopy
}

// MinimockAcceptRefundDone returns true if the count of the AcceptRefund invocations corresponds
// the number of defined expectations
func (m *UsecasesMock) MinimockAcceptRefundDone() bool {
	if m.AcceptRefundMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AcceptRefundMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AcceptRefundMock.invocationsDone()
}

// MinimockAcceptRefundInspect logs each unmet expectation
func (m *UsecasesMock) MinimockAcceptRefundInspect() {
	for _, e := range m.AcceptRefundMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UsecasesMock.AcceptRefund at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAcceptRefundCounter := mm_atomic.LoadUint64(&m.afterAcceptRefundCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AcceptRefundMock.defaultExpectation != nil && afterAcceptRefundCounter < 1 {
		if m.AcceptRefundMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UsecasesMock.AcceptRefund at\n%s", m.AcceptRefundMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UsecasesMock.AcceptRefund at\n%s with params: %#v", m.AcceptRefundMock.defaultExpectation.expectationOrigins.origin, *m.AcceptRefundMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAcceptRefund != nil && afterAcceptRefundCounter < 1 {
		m.t.Errorf("Expected call to UsecasesMock.AcceptRefund at\n%s", m.funcAcceptRefundOrigin)
	}

	if !m.AcceptRefundMock.invocationsDone() && afterAcceptRefundCounter > 0 {
		m.t.Errorf("Expected %d calls to UsecasesMock.AcceptRefund at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AcceptRefundMock.expectedInvocations), m.AcceptRefundMock.expectedInvocationsOrigin, afterAcceptRefundCounter)
	}
}

type mUsecasesMockGetOrders struct {
	optional           bool
	mock               *UsecasesMock
	defaultExpectation *UsecasesMockGetOrdersExpectation
	expectations       []*UsecasesMockGetOrdersExpectation

	callArgs []*UsecasesMockGetOrdersParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UsecasesMockGetOrdersExpectation specifies expectation struct of the Usecases.GetOrders
type UsecasesMockGetOrdersExpectation struct {
	mock               *UsecasesMock
	params             *UsecasesMockGetOrdersParams
	paramPtrs          *UsecasesMockGetOrdersParamPtrs
	expectationOrigins UsecasesMockGetOrdersExpectationOrigins
	results            *UsecasesMockGetOrdersResults
	returnOrigin       string
	Counter            uint64
}

// UsecasesMockGetOrdersParams contains parameters of the Usecases.GetOrders
type UsecasesMockGetOrdersParams struct {
	req *dto.ViewOrdersRequest
}

// UsecasesMockGetOrdersParamPtrs contains pointers to parameters of the Usecases.GetOrders
type UsecasesMockGetOrdersParamPtrs struct {
	req **dto.ViewOrdersRequest
}

// UsecasesMockGetOrdersResults contains results of the Usecases.GetOrders
type UsecasesMockGetOrdersResults struct {
	oa1 []domain.OrderView
	err error
}

// UsecasesMockGetOrdersOrigins contains origins of expectations of the Usecases.GetOrders
type UsecasesMockGetOrdersExpectationOrigins struct {
	origin    string
	originReq string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrders *mUsecasesMockGetOrders) Optional() *mUsecasesMockGetOrders {
	mmGetOrders.optional = true
	return mmGetOrders
}

// Expect sets up expected params for Usecases.GetOrders
func (mmGetOrders *mUsecasesMockGetOrders) Expect(req *dto.ViewOrdersRequest) *mUsecasesMockGetOrders {
	if mmGetOrders.mock.funcGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("UsecasesMock.GetOrders mock is already set by Set")
	}

	if mmGetOrders.defaultExpectation == nil {
		mmGetOrders.defaultExpectation = &UsecasesMockGetOrdersExpectation{}
	}

	if mmGetOrders.defaultExpectation.paramPtrs != nil {
		mmGetOrders.mock.t.Fatalf("UsecasesMock.GetOrders mock is already set by ExpectParams functions")
	}

	mmGetOrders.defaultExpectation.params = &UsecasesMockGetOrdersParams{req}
	mmGetOrders.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetOrders.expectations {
		if minimock.Equal(e.params, mmGetOrders.defaultExpectation.params) {
			mmGetOrders.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrders.defaultExpectation.params)
		}
	}

	return mmGetOrders
}

// ExpectReqParam1 sets up expected param req for Usecases.GetOrders
func (mmGetOrders *mUsecasesMockGetOrders) ExpectReqParam1(req *dto.ViewOrdersRequest) *mUsecasesMockGetOrders {
	if mmGetOrders.mock.funcGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("UsecasesMock.GetOrders mock is already set by Set")
	}

	if mmGetOrders.defaultExpectation == nil {
		mmGetOrders.defaultExpectation = &UsecasesMockGetOrdersExpectation{}
	}

	if mmGetOrders.defaultExpectation.params != nil {
		mmGetOrders.mock.t.Fatalf("UsecasesMock.GetOrders mock is already set by Expect")
	}

	if mmGetOrders.defaultExpectation.paramPtrs == nil {
		mmGetOrders.defaultExpectation.paramPtrs = &UsecasesMockGetOrdersParamPtrs{}
	}
	mmGetOrders.defaultExpectation.paramPtrs.req = &req
	mmGetOrders.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmGetOrders
}

// Inspect accepts an inspector function that has same arguments as the Usecases.GetOrders
func (mmGetOrders *mUsecasesMockGetOrders) Inspect(f func(req *dto.ViewOrdersRequest)) *mUsecasesMockGetOrders {
	if mmGetOrders.mock.inspectFuncGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("Inspect function is already set for UsecasesMock.GetOrders")
	}

	mmGetOrders.mock.inspectFuncGetOrders = f

	return mmGetOrders
}

// Return sets up results that will be returned by Usecases.GetOrders
func (mmGetOrders *mUsecasesMockGetOrders) Return(oa1 []domain.OrderView, err error) *UsecasesMock {
	if mmGetOrders.mock.funcGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("UsecasesMock.GetOrders mock is already set by Set")
	}

	if mmGetOrders.defaultExpectation == nil {
		mmGetOrders.defaultExpectation = &UsecasesMockGetOrdersExpectation{mock: mmGetOrders.mock}
	}
	mmGetOrders.defaultExpectation.results = &UsecasesMockGetOrdersResults{oa1, err}
	mmGetOrders.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOrders.mock
}

// Set uses given function f to mock the Usecases.GetOrders method
func (mmGetOrders *mUsecasesMockGetOrders) Set(f func(req *dto.ViewOrdersRequest) (oa1 []domain.OrderView, err error)) *UsecasesMock {
	if mmGetOrders.defaultExpectation != nil {
		mmGetOrders.mock.t.Fatalf("Default expectation is already set for the Usecases.GetOrders method")
	}

	if len(mmGetOrders.expectations) > 0 {
		mmGetOrders.mock.t.Fatalf("Some expectations are already set for the Usecases.GetOrders method")
	}

	mmGetOrders.mock.funcGetOrders = f
	mmGetOrders.mock.funcGetOrdersOrigin = minimock.CallerInfo(1)
	return mmGetOrders.mock
}

// When sets expectation for the Usecases.GetOrders which will trigger the result defined by the following
// Then helper
func (mmGetOrders *mUsecasesMockGetOrders) When(req *dto.ViewOrdersRequest) *UsecasesMockGetOrdersExpectation {
	if mmGetOrders.mock.funcGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("UsecasesMock.GetOrders mock is already set by Set")
	}

	expectation := &UsecasesMockGetOrdersExpectation{
		mock:               mmGetOrders.mock,
		params:             &UsecasesMockGetOrdersParams{req},
		expectationOrigins: UsecasesMockGetOrdersExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetOrders.expectations = append(mmGetOrders.expectations, expectation)
	return expectation
}

// Then sets up Usecases.GetOrders return parameters for the expectation previously defined by the When method
func (e *UsecasesMockGetOrdersExpectation) Then(oa1 []domain.OrderView, err error) *UsecasesMock {
	e.results = &UsecasesMockGetOrdersResults{oa1, err}
	return e.mock
}

// Times sets number of times Usecases.GetOrders should be invoked
func (mmGetOrders *mUsecasesMockGetOrders) Times(n uint64) *mUsecasesMockGetOrders {
	if n == 0 {
		mmGetOrders.mock.t.Fatalf("Times of UsecasesMock.GetOrders mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrders.expectedInvocations, n)
	mmGetOrders.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOrders
}

func (mmGetOrders *mUsecasesMockGetOrders) invocationsDone() bool {
	if len(mmGetOrders.expectations) == 0 && mmGetOrders.defaultExpectation == nil && mmGetOrders.mock.funcGetOrders == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrders.mock.afterGetOrdersCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrders.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrders implements mm_manager_service.Usecases
func (mmGetOrders *UsecasesMock) GetOrders(req *dto.ViewOrdersRequest) (oa1 []domain.OrderView, err error) {
	mm_atomic.AddUint64(&mmGetOrders.beforeGetOrdersCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrders.afterGetOrdersCounter, 1)

	mmGetOrders.t.Helper()

	if mmGetOrders.inspectFuncGetOrders != nil {
		mmGetOrders.inspectFuncGetOrders(req)
	}

	mm_params := UsecasesMockGetOrdersParams{req}

	// Record call args
	mmGetOrders.GetOrdersMock.mutex.Lock()
	mmGetOrders.GetOrdersMock.callArgs = append(mmGetOrders.GetOrdersMock.callArgs, &mm_params)
	mmGetOrders.GetOrdersMock.mutex.Unlock()

	for _, e := range mmGetOrders.GetOrdersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.err
		}
	}

	if mmGetOrders.GetOrdersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrders.GetOrdersMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrders.GetOrdersMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrders.GetOrdersMock.defaultExpectation.paramPtrs

		mm_got := UsecasesMockGetOrdersParams{req}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmGetOrders.t.Errorf("UsecasesMock.GetOrders got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrders.GetOrdersMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrders.t.Errorf("UsecasesMock.GetOrders got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetOrders.GetOrdersMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrders.GetOrdersMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrders.t.Fatal("No results are set for the UsecasesMock.GetOrders")
		}
		return (*mm_results).oa1, (*mm_results).err
	}
	if mmGetOrders.funcGetOrders != nil {
		return mmGetOrders.funcGetOrders(req)
	}
	mmGetOrders.t.Fatalf("Unexpected call to UsecasesMock.GetOrders. %v", req)
	return
}

// GetOrdersAfterCounter returns a count of finished UsecasesMock.GetOrders invocations
func (mmGetOrders *UsecasesMock) GetOrdersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrders.afterGetOrdersCounter)
}

// GetOrdersBeforeCounter returns a count of UsecasesMock.GetOrders invocations
func (mmGetOrders *UsecasesMock) GetOrdersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrders.beforeGetOrdersCounter)
}

// Calls returns a list of arguments used in each call to UsecasesMock.GetOrders.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrders *mUsecasesMockGetOrders) Calls() []*UsecasesMockGetOrdersParams {
	mmGetOrders.mutex.RLock()

	argCopy := make([]*UsecasesMockGetOrdersParams, len(mmGetOrders.callArgs))
	copy(argCopy, mmGetOrders.callArgs)

	mmGetOrders.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrdersDone returns true if the count of the GetOrders invocations corresponds
// the number of defined expectations
func (m *UsecasesMock) MinimockGetOrdersDone() bool {
	if m.GetOrdersMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrdersMock.invocationsDone()
}

// MinimockGetOrdersInspect logs each unmet expectation
func (m *UsecasesMock) MinimockGetOrdersInspect() {
	for _, e := range m.GetOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UsecasesMock.GetOrders at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetOrdersCounter := mm_atomic.LoadUint64(&m.afterGetOrdersCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrdersMock.defaultExpectation != nil && afterGetOrdersCounter < 1 {
		if m.GetOrdersMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UsecasesMock.GetOrders at\n%s", m.GetOrdersMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UsecasesMock.GetOrders at\n%s with params: %#v", m.GetOrdersMock.defaultExpectation.expectationOrigins.origin, *m.GetOrdersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrders != nil && afterGetOrdersCounter < 1 {
		m.t.Errorf("Expected call to UsecasesMock.GetOrders at\n%s", m.funcGetOrdersOrigin)
	}

	if !m.GetOrdersMock.invocationsDone() && afterGetOrdersCounter > 0 {
		m.t.Errorf("Expected %d calls to UsecasesMock.GetOrders at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrdersMock.expectedInvocations), m.GetOrdersMock.expectedInvocationsOrigin, afterGetOrdersCounter)
	}
}

type mUsecasesMockGetRefunds struct {
	optional           bool
	mock               *UsecasesMock
	defaultExpectation *UsecasesMockGetRefundsExpectation
	expectations       []*UsecasesMockGetRefundsExpectation

	callArgs []*UsecasesMockGetRefundsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UsecasesMockGetRefundsExpectation specifies expectation struct of the Usecases.GetRefunds
type UsecasesMockGetRefundsExpectation struct {
	mock               *UsecasesMock
	params             *UsecasesMockGetRefundsParams
	paramPtrs          *UsecasesMockGetRefundsParamPtrs
	expectationOrigins UsecasesMockGetRefundsExpectationOrigins
	results            *UsecasesMockGetRefundsResults
	returnOrigin       string
	Counter            uint64
}

// UsecasesMockGetRefundsParams contains parameters of the Usecases.GetRefunds
type UsecasesMockGetRefundsParams struct {
	req *dto.ViewRefundsRequest
}

// UsecasesMockGetRefundsParamPtrs contains pointers to parameters of the Usecases.GetRefunds
type UsecasesMockGetRefundsParamPtrs struct {
	req **dto.ViewRefundsRequest
}

// UsecasesMockGetRefundsResults contains results of the Usecases.GetRefunds
type UsecasesMockGetRefundsResults struct {
	oa1 []domain.OrderView
	err error
}

// UsecasesMockGetRefundsOrigins contains origins of expectations of the Usecases.GetRefunds
type UsecasesMockGetRefundsExpectationOrigins struct {
	origin    string
	originReq string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetRefunds *mUsecasesMockGetRefunds) Optional() *mUsecasesMockGetRefunds {
	mmGetRefunds.optional = true
	return mmGetRefunds
}

// Expect sets up expected params for Usecases.GetRefunds
func (mmGetRefunds *mUsecasesMockGetRefunds) Expect(req *dto.ViewRefundsRequest) *mUsecasesMockGetRefunds {
	if mmGetRefunds.mock.funcGetRefunds != nil {
		mmGetRefunds.mock.t.Fatalf("UsecasesMock.GetRefunds mock is already set by Set")
	}

	if mmGetRefunds.defaultExpectation == nil {
		mmGetRefunds.defaultExpectation = &UsecasesMockGetRefundsExpectation{}
	}

	if mmGetRefunds.defaultExpectation.paramPtrs != nil {
		mmGetRefunds.mock.t.Fatalf("UsecasesMock.GetRefunds mock is already set by ExpectParams functions")
	}

	mmGetRefunds.defaultExpectation.params = &UsecasesMockGetRefundsParams{req}
	mmGetRefunds.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetRefunds.expectations {
		if minimock.Equal(e.params, mmGetRefunds.defaultExpectation.params) {
			mmGetRefunds.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRefunds.defaultExpectation.params)
		}
	}

	return mmGetRefunds
}

// ExpectReqParam1 sets up expected param req for Usecases.GetRefunds
func (mmGetRefunds *mUsecasesMockGetRefunds) ExpectReqParam1(req *dto.ViewRefundsRequest) *mUsecasesMockGetRefunds {
	if mmGetRefunds.mock.funcGetRefunds != nil {
		mmGetRefunds.mock.t.Fatalf("UsecasesMock.GetRefunds mock is already set by Set")
	}

	if mmGetRefunds.defaultExpectation == nil {
		mmGetRefunds.defaultExpectation = &UsecasesMockGetRefundsExpectation{}
	}

	if mmGetRefunds.defaultExpectation.params != nil {
		mmGetRefunds.mock.t.Fatalf("UsecasesMock.GetRefunds mock is already set by Expect")
	}

	if mmGetRefunds.defaultExpectation.paramPtrs == nil {
		mmGetRefunds.defaultExpectation.paramPtrs = &UsecasesMockGetRefundsParamPtrs{}
	}
	mmGetRefunds.defaultExpectation.paramPtrs.req = &req
	mmGetRefunds.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmGetRefunds
}

// Inspect accepts an inspector function that has same arguments as the Usecases.GetRefunds
func (mmGetRefunds *mUsecasesMockGetRefunds) Inspect(f func(req *dto.ViewRefundsRequest)) *mUsecasesMockGetRefunds {
	if mmGetRefunds.mock.inspectFuncGetRefunds != nil {
		mmGetRefunds.mock.t.Fatalf("Inspect function is already set for UsecasesMock.GetRefunds")
	}

	mmGetRefunds.mock.inspectFuncGetRefunds = f

	return mmGetRefunds
}

// Return sets up results that will be returned by Usecases.GetRefunds
func (mmGetRefunds *mUsecasesMockGetRefunds) Return(oa1 []domain.OrderView, err error) *UsecasesMock {
	if mmGetRefunds.mock.funcGetRefunds != nil {
		mmGetRefunds.mock.t.Fatalf("UsecasesMock.GetRefunds mock is already set by Set")
	}

	if mmGetRefunds.defaultExpectation == nil {
		mmGetRefunds.defaultExpectation = &UsecasesMockGetRefundsExpectation{mock: mmGetRefunds.mock}
	}
	mmGetRefunds.defaultExpectation.results = &UsecasesMockGetRefundsResults{oa1, err}
	mmGetRefunds.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetRefunds.mock
}

// Set uses given function f to mock the Usecases.GetRefunds method
func (mmGetRefunds *mUsecasesMockGetRefunds) Set(f func(req *dto.ViewRefundsRequest) (oa1 []domain.OrderView, err error)) *UsecasesMock {
	if mmGetRefunds.defaultExpectation != nil {
		mmGetRefunds.mock.t.Fatalf("Default expectation is already set for the Usecases.GetRefunds method")
	}

	if len(mmGetRefunds.expectations) > 0 {
		mmGetRefunds.mock.t.Fatalf("Some expectations are already set for the Usecases.GetRefunds method")
	}

	mmGetRefunds.mock.funcGetRefunds = f
	mmGetRefunds.mock.funcGetRefundsOrigin = minimock.CallerInfo(1)
	return mmGetRefunds.mock
}

// When sets expectation for the Usecases.GetRefunds which will trigger the result defined by the following
// Then helper
func (mmGetRefunds *mUsecasesMockGetRefunds) When(req *dto.ViewRefundsRequest) *UsecasesMockGetRefundsExpectation {
	if mmGetRefunds.mock.funcGetRefunds != nil {
		mmGetRefunds.mock.t.Fatalf("UsecasesMock.GetRefunds mock is already set by Set")
	}

	expectation := &UsecasesMockGetRefundsExpectation{
		mock:               mmGetRefunds.mock,
		params:             &UsecasesMockGetRefundsParams{req},
		expectationOrigins: UsecasesMockGetRefundsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetRefunds.expectations = append(mmGetRefunds.expectations, expectation)
	return expectation
}

// Then sets up Usecases.GetRefunds return parameters for the expectation previously defined by the When method
func (e *UsecasesMockGetRefundsExpectation) Then(oa1 []domain.OrderView, err error) *UsecasesMock {
	e.results = &UsecasesMockGetRefundsResults{oa1, err}
	return e.mock
}

// Times sets number of times Usecases.GetRefunds should be invoked
func (mmGetRefunds *mUsecasesMockGetRefunds) Times(n uint64) *mUsecasesMockGetRefunds {
	if n == 0 {
		mmGetRefunds.mock.t.Fatalf("Times of UsecasesMock.GetRefunds mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetRefunds.expectedInvocations, n)
	mmGetRefunds.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetRefunds
}

func (mmGetRefunds *mUsecasesMockGetRefunds) invocationsDone() bool {
	if len(mmGetRefunds.expectations) == 0 && mmGetRefunds.defaultExpectation == nil && mmGetRefunds.mock.funcGetRefunds == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetRefunds.mock.afterGetRefundsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetRefunds.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetRefunds implements mm_manager_service.Usecases
func (mmGetRefunds *UsecasesMock) GetRefunds(req *dto.ViewRefundsRequest) (oa1 []domain.OrderView, err error) {
	mm_atomic.AddUint64(&mmGetRefunds.beforeGetRefundsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRefunds.afterGetRefundsCounter, 1)

	mmGetRefunds.t.Helper()

	if mmGetRefunds.inspectFuncGetRefunds != nil {
		mmGetRefunds.inspectFuncGetRefunds(req)
	}

	mm_params := UsecasesMockGetRefundsParams{req}

	// Record call args
	mmGetRefunds.GetRefundsMock.mutex.Lock()
	mmGetRefunds.GetRefundsMock.callArgs = append(mmGetRefunds.GetRefundsMock.callArgs, &mm_params)
	mmGetRefunds.GetRefundsMock.mutex.Unlock()

	for _, e := range mmGetRefunds.GetRefundsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.err
		}
	}

	if mmGetRefunds.GetRefundsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRefunds.GetRefundsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRefunds.GetRefundsMock.defaultExpectation.params
		mm_want_ptrs := mmGetRefunds.GetRefundsMock.defaultExpectation.paramPtrs

		mm_got := UsecasesMockGetRefundsParams{req}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmGetRefunds.t.Errorf("UsecasesMock.GetRefunds got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetRefunds.GetRefundsMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRefunds.t.Errorf("UsecasesMock.GetRefunds got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetRefunds.GetRefundsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRefunds.GetRefundsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRefunds.t.Fatal("No results are set for the UsecasesMock.GetRefunds")
		}
		return (*mm_results).oa1, (*mm_results).err
	}
	if mmGetRefunds.funcGetRefunds != nil {
		return mmGetRefunds.funcGetRefunds(req)
	}
	mmGetRefunds.t.Fatalf("Unexpected call to UsecasesMock.GetRefunds. %v", req)
	return
}

// GetRefundsAfterCounter returns a count of finished UsecasesMock.GetRefunds invocations
func (mmGetRefunds *UsecasesMock) GetRefundsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRefunds.afterGetRefundsCounter)
}

// GetRefundsBeforeCounter returns a count of UsecasesMock.GetRefunds invocations
func (mmGetRefunds *UsecasesMock) GetRefundsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRefunds.beforeGetRefundsCounter)
}

// Calls returns a list of arguments used in each call to UsecasesMock.GetRefunds.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRefunds *mUsecasesMockGetRefunds) Calls() []*UsecasesMockGetRefundsParams {
	mmGetRefunds.mutex.RLock()

	argCopy := make([]*UsecasesMockGetRefundsParams, len(mmGetRefunds.callArgs))
	copy(argCopy, mmGetRefunds.callArgs)

	mmGetRefunds.mutex.RUnlock()

	return argCopy
}

// MinimockGetRefundsDone returns true if the count of the GetRefunds invocations corresponds
// the number of defined expectations
func (m *UsecasesMock) MinimockGetRefundsDone() bool {
	if m.GetRefundsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetRefundsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetRefundsMock.invocationsDone()
}

// MinimockGetRefundsInspect logs each unmet expectation
func (m *UsecasesMock) MinimockGetRefundsInspect() {
	for _, e := range m.GetRefundsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UsecasesMock.GetRefunds at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetRefundsCounter := mm_atomic.LoadUint64(&m.afterGetRefundsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetRefundsMock.defaultExpectation != nil && afterGetRefundsCounter < 1 {
		if m.GetRefundsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UsecasesMock.GetRefunds at\n%s", m.GetRefundsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UsecasesMock.GetRefunds at\n%s with params: %#v", m.GetRefundsMock.defaultExpectation.expectationOrigins.origin, *m.GetRefundsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRefunds != nil && afterGetRefundsCounter < 1 {
		m.t.Errorf("Expected call to UsecasesMock.GetRefunds at\n%s", m.funcGetRefundsOrigin)
	}

	if !m.GetRefundsMock.invocationsDone() && afterGetRefundsCounter > 0 {
		m.t.Errorf("Expected %d calls to UsecasesMock.GetRefunds at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetRefundsMock.expectedInvocations), m.GetRefundsMock.expectedInvocationsOrigin, afterGetRefundsCounter)
	}
}

type mUsecasesMockGive struct {
	optional           bool
	mock               *UsecasesMock
	defaultExpectation *UsecasesMockGiveExpectation
	expectations       []*UsecasesMockGiveExpectation

	callArgs []*UsecasesMockGiveParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UsecasesMockGiveExpectation specifies expectation struct of the Usecases.Give
type UsecasesMockGiveExpectation struct {
	mock               *UsecasesMock
	params             *UsecasesMockGiveParams
	paramPtrs          *UsecasesMockGiveParamPtrs
	expectationOrigins UsecasesMockGiveExpectationOrigins
	results            *UsecasesMockGiveResults
	returnOrigin       string
	Counter            uint64
}

// UsecasesMockGiveParams contains parameters of the Usecases.Give
type UsecasesMockGiveParams struct {
	req *dto.GiveOrdersRequest
}

// UsecasesMockGiveParamPtrs contains pointers to parameters of the Usecases.Give
type UsecasesMockGiveParamPtrs struct {
	req **dto.GiveOrdersRequest
}

// UsecasesMockGiveResults contains results of the Usecases.Give
type UsecasesMockGiveResults struct {
	ea1 []error
}

// UsecasesMockGiveOrigins contains origins of expectations of the Usecases.Give
type UsecasesMockGiveExpectationOrigins struct {
	origin    string
	originReq string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGive *mUsecasesMockGive) Optional() *mUsecasesMockGive {
	mmGive.optional = true
	return mmGive
}

// Expect sets up expected params for Usecases.Give
func (mmGive *mUsecasesMockGive) Expect(req *dto.GiveOrdersRequest) *mUsecasesMockGive {
	if mmGive.mock.funcGive != nil {
		mmGive.mock.t.Fatalf("UsecasesMock.Give mock is already set by Set")
	}

	if mmGive.defaultExpectation == nil {
		mmGive.defaultExpectation = &UsecasesMockGiveExpectation{}
	}

	if mmGive.defaultExpectation.paramPtrs != nil {
		mmGive.mock.t.Fatalf("UsecasesMock.Give mock is already set by ExpectParams functions")
	}

	mmGive.defaultExpectation.params = &UsecasesMockGiveParams{req}
	mmGive.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGive.expectations {
		if minimock.Equal(e.params, mmGive.defaultExpectation.params) {
			mmGive.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGive.defaultExpectation.params)
		}
	}

	return mmGive
}

// ExpectReqParam1 sets up expected param req for Usecases.Give
func (mmGive *mUsecasesMockGive) ExpectReqParam1(req *dto.GiveOrdersRequest) *mUsecasesMockGive {
	if mmGive.mock.funcGive != nil {
		mmGive.mock.t.Fatalf("UsecasesMock.Give mock is already set by Set")
	}

	if mmGive.defaultExpectation == nil {
		mmGive.defaultExpectation = &UsecasesMockGiveExpectation{}
	}

	if mmGive.defaultExpectation.params != nil {
		mmGive.mock.t.Fatalf("UsecasesMock.Give mock is already set by Expect")
	}

	if mmGive.defaultExpectation.paramPtrs == nil {
		mmGive.defaultExpectation.paramPtrs = &UsecasesMockGiveParamPtrs{}
	}
	mmGive.defaultExpectation.paramPtrs.req = &req
	mmGive.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmGive
}

// Inspect accepts an inspector function that has same arguments as the Usecases.Give
func (mmGive *mUsecasesMockGive) Inspect(f func(req *dto.GiveOrdersRequest)) *mUsecasesMockGive {
	if mmGive.mock.inspectFuncGive != nil {
		mmGive.mock.t.Fatalf("Inspect function is already set for UsecasesMock.Give")
	}

	mmGive.mock.inspectFuncGive = f

	return mmGive
}

// Return sets up results that will be returned by Usecases.Give
func (mmGive *mUsecasesMockGive) Return(ea1 []error) *UsecasesMock {
	if mmGive.mock.funcGive != nil {
		mmGive.mock.t.Fatalf("UsecasesMock.Give mock is already set by Set")
	}

	if mmGive.defaultExpectation == nil {
		mmGive.defaultExpectation = &UsecasesMockGiveExpectation{mock: mmGive.mock}
	}
	mmGive.defaultExpectation.results = &UsecasesMockGiveResults{ea1}
	mmGive.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGive.mock
}

// Set uses given function f to mock the Usecases.Give method
func (mmGive *mUsecasesMockGive) Set(f func(req *dto.GiveOrdersRequest) (ea1 []error)) *UsecasesMock {
	if mmGive.defaultExpectation != nil {
		mmGive.mock.t.Fatalf("Default expectation is already set for the Usecases.Give method")
	}

	if len(mmGive.expectations) > 0 {
		mmGive.mock.t.Fatalf("Some expectations are already set for the Usecases.Give method")
	}

	mmGive.mock.funcGive = f
	mmGive.mock.funcGiveOrigin = minimock.CallerInfo(1)
	return mmGive.mock
}

// When sets expectation for the Usecases.Give which will trigger the result defined by the following
// Then helper
func (mmGive *mUsecasesMockGive) When(req *dto.GiveOrdersRequest) *UsecasesMockGiveExpectation {
	if mmGive.mock.funcGive != nil {
		mmGive.mock.t.Fatalf("UsecasesMock.Give mock is already set by Set")
	}

	expectation := &UsecasesMockGiveExpectation{
		mock:               mmGive.mock,
		params:             &UsecasesMockGiveParams{req},
		expectationOrigins: UsecasesMockGiveExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGive.expectations = append(mmGive.expectations, expectation)
	return expectation
}

// Then sets up Usecases.Give return parameters for the expectation previously defined by the When method
func (e *UsecasesMockGiveExpectation) Then(ea1 []error) *UsecasesMock {
	e.results = &UsecasesMockGiveResults{ea1}
	return e.mock
}

// Times sets number of times Usecases.Give should be invoked
func (mmGive *mUsecasesMockGive) Times(n uint64) *mUsecasesMockGive {
	if n == 0 {
		mmGive.mock.t.Fatalf("Times of UsecasesMock.Give mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGive.expectedInvocations, n)
	mmGive.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGive
}

func (mmGive *mUsecasesMockGive) invocationsDone() bool {
	if len(mmGive.expectations) == 0 && mmGive.defaultExpectation == nil && mmGive.mock.funcGive == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGive.mock.afterGiveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGive.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Give implements mm_manager_service.Usecases
func (mmGive *UsecasesMock) Give(req *dto.GiveOrdersRequest) (ea1 []error) {
	mm_atomic.AddUint64(&mmGive.beforeGiveCounter, 1)
	defer mm_atomic.AddUint64(&mmGive.afterGiveCounter, 1)

	mmGive.t.Helper()

	if mmGive.inspectFuncGive != nil {
		mmGive.inspectFuncGive(req)
	}

	mm_params := UsecasesMockGiveParams{req}

	// Record call args
	mmGive.GiveMock.mutex.Lock()
	mmGive.GiveMock.callArgs = append(mmGive.GiveMock.callArgs, &mm_params)
	mmGive.GiveMock.mutex.Unlock()

	for _, e := range mmGive.GiveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ea1
		}
	}

	if mmGive.GiveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGive.GiveMock.defaultExpectation.Counter, 1)
		mm_want := mmGive.GiveMock.defaultExpectation.params
		mm_want_ptrs := mmGive.GiveMock.defaultExpectation.paramPtrs

		mm_got := UsecasesMockGiveParams{req}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmGive.t.Errorf("UsecasesMock.Give got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGive.GiveMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGive.t.Errorf("UsecasesMock.Give got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGive.GiveMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGive.GiveMock.defaultExpectation.results
		if mm_results == nil {
			mmGive.t.Fatal("No results are set for the UsecasesMock.Give")
		}
		return (*mm_results).ea1
	}
	if mmGive.funcGive != nil {
		return mmGive.funcGive(req)
	}
	mmGive.t.Fatalf("Unexpected call to UsecasesMock.Give. %v", req)
	return
}

// GiveAfterCounter returns a count of finished UsecasesMock.Give invocations
func (mmGive *UsecasesMock) GiveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGive.afterGiveCounter)
}

// GiveBeforeCounter returns a count of UsecasesMock.Give invocations
func (mmGive *UsecasesMock) GiveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGive.beforeGiveCounter)
}

// Calls returns a list of arguments used in each call to UsecasesMock.Give.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGive *mUsecasesMockGive) Calls() []*UsecasesMockGiveParams {
	mmGive.mutex.RLock()

	argCopy := make([]*UsecasesMockGiveParams, len(mmGive.callArgs))
	copy(argCopy, mmGive.callArgs)

	mmGive.mutex.RUnlock()

	return argCopy
}

// MinimockGiveDone returns true if the count of the Give invocations corresponds
// the number of defined expectations
func (m *UsecasesMock) MinimockGiveDone() bool {
	if m.GiveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GiveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GiveMock.invocationsDone()
}

// MinimockGiveInspect logs each unmet expectation
func (m *UsecasesMock) MinimockGiveInspect() {
	for _, e := range m.GiveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UsecasesMock.Give at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGiveCounter := mm_atomic.LoadUint64(&m.afterGiveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GiveMock.defaultExpectation != nil && afterGiveCounter < 1 {
		if m.GiveMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UsecasesMock.Give at\n%s", m.GiveMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UsecasesMock.Give at\n%s with params: %#v", m.GiveMock.defaultExpectation.expectationOrigins.origin, *m.GiveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGive != nil && afterGiveCounter < 1 {
		m.t.Errorf("Expected call to UsecasesMock.Give at\n%s", m.funcGiveOrigin)
	}

	if !m.GiveMock.invocationsDone() && afterGiveCounter > 0 {
		m.t.Errorf("Expected %d calls to UsecasesMock.Give at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GiveMock.expectedInvocations), m.GiveMock.expectedInvocationsOrigin, afterGiveCounter)
	}
}

type mUsecasesMockReturn struct {
	optional           bool
	mock               *UsecasesMock
	defaultExpectation *UsecasesMockReturnExpectation
	expectations       []*UsecasesMockReturnExpectation

	callArgs []*UsecasesMockReturnParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UsecasesMockReturnExpectation specifies expectation struct of the Usecases.Return
type UsecasesMockReturnExpectation struct {
	mock               *UsecasesMock
	params             *UsecasesMockReturnParams
	paramPtrs          *UsecasesMockReturnParamPtrs
	expectationOrigins UsecasesMockReturnExpectationOrigins
	results            *UsecasesMockReturnResults
	returnOrigin       string
	Counter            uint64
}

// UsecasesMockReturnParams contains parameters of the Usecases.Return
type UsecasesMockReturnParams struct {
	req *dto.ReturnRequest
}

// UsecasesMockReturnParamPtrs contains pointers to parameters of the Usecases.Return
type UsecasesMockReturnParamPtrs struct {
	req **dto.ReturnRequest
}

// UsecasesMockReturnResults contains results of the Usecases.Return
type UsecasesMockReturnResults struct {
	err error
}

// UsecasesMockReturnOrigins contains origins of expectations of the Usecases.Return
type UsecasesMockReturnExpectationOrigins struct {
	origin    string
	originReq string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReturn *mUsecasesMockReturn) Optional() *mUsecasesMockReturn {
	mmReturn.optional = true
	return mmReturn
}

// Expect sets up expected params for Usecases.Return
func (mmReturn *mUsecasesMockReturn) Expect(req *dto.ReturnRequest) *mUsecasesMockReturn {
	if mmReturn.mock.funcReturn != nil {
		mmReturn.mock.t.Fatalf("UsecasesMock.Return mock is already set by Set")
	}

	if mmReturn.defaultExpectation == nil {
		mmReturn.defaultExpectation = &UsecasesMockReturnExpectation{}
	}

	if mmReturn.defaultExpectation.paramPtrs != nil {
		mmReturn.mock.t.Fatalf("UsecasesMock.Return mock is already set by ExpectParams functions")
	}

	mmReturn.defaultExpectation.params = &UsecasesMockReturnParams{req}
	mmReturn.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReturn.expectations {
		if minimock.Equal(e.params, mmReturn.defaultExpectation.params) {
			mmReturn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReturn.defaultExpectation.params)
		}
	}

	return mmReturn
}

// ExpectReqParam1 sets up expected param req for Usecases.Return
func (mmReturn *mUsecasesMockReturn) ExpectReqParam1(req *dto.ReturnRequest) *mUsecasesMockReturn {
	if mmReturn.mock.funcReturn != nil {
		mmReturn.mock.t.Fatalf("UsecasesMock.Return mock is already set by Set")
	}

	if mmReturn.defaultExpectation == nil {
		mmReturn.defaultExpectation = &UsecasesMockReturnExpectation{}
	}

	if mmReturn.defaultExpectation.params != nil {
		mmReturn.mock.t.Fatalf("UsecasesMock.Return mock is already set by Expect")
	}

	if mmReturn.defaultExpectation.paramPtrs == nil {
		mmReturn.defaultExpectation.paramPtrs = &UsecasesMockReturnParamPtrs{}
	}
	mmReturn.defaultExpectation.paramPtrs.req = &req
	mmReturn.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmReturn
}

// Inspect accepts an inspector function that has same arguments as the Usecases.Return
func (mmReturn *mUsecasesMockReturn) Inspect(f func(req *dto.ReturnRequest)) *mUsecasesMockReturn {
	if mmReturn.mock.inspectFuncReturn != nil {
		mmReturn.mock.t.Fatalf("Inspect function is already set for UsecasesMock.Return")
	}

	mmReturn.mock.inspectFuncReturn = f

	return mmReturn
}

// Return sets up results that will be returned by Usecases.Return
func (mmReturn *mUsecasesMockReturn) Return(err error) *UsecasesMock {
	if mmReturn.mock.funcReturn != nil {
		mmReturn.mock.t.Fatalf("UsecasesMock.Return mock is already set by Set")
	}

	if mmReturn.defaultExpectation == nil {
		mmReturn.defaultExpectation = &UsecasesMockReturnExpectation{mock: mmReturn.mock}
	}
	mmReturn.defaultExpectation.results = &UsecasesMockReturnResults{err}
	mmReturn.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReturn.mock
}

// Set uses given function f to mock the Usecases.Return method
func (mmReturn *mUsecasesMockReturn) Set(f func(req *dto.ReturnRequest) (err error)) *UsecasesMock {
	if mmReturn.defaultExpectation != nil {
		mmReturn.mock.t.Fatalf("Default expectation is already set for the Usecases.Return method")
	}

	if len(mmReturn.expectations) > 0 {
		mmReturn.mock.t.Fatalf("Some expectations are already set for the Usecases.Return method")
	}

	mmReturn.mock.funcReturn = f
	mmReturn.mock.funcReturnOrigin = minimock.CallerInfo(1)
	return mmReturn.mock
}

// When sets expectation for the Usecases.Return which will trigger the result defined by the following
// Then helper
func (mmReturn *mUsecasesMockReturn) When(req *dto.ReturnRequest) *UsecasesMockReturnExpectation {
	if mmReturn.mock.funcReturn != nil {
		mmReturn.mock.t.Fatalf("UsecasesMock.Return mock is already set by Set")
	}

	expectation := &UsecasesMockReturnExpectation{
		mock:               mmReturn.mock,
		params:             &UsecasesMockReturnParams{req},
		expectationOrigins: UsecasesMockReturnExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReturn.expectations = append(mmReturn.expectations, expectation)
	return expectation
}

// Then sets up Usecases.Return return parameters for the expectation previously defined by the When method
func (e *UsecasesMockReturnExpectation) Then(err error) *UsecasesMock {
	e.results = &UsecasesMockReturnResults{err}
	return e.mock
}

// Times sets number of times Usecases.Return should be invoked
func (mmReturn *mUsecasesMockReturn) Times(n uint64) *mUsecasesMockReturn {
	if n == 0 {
		mmReturn.mock.t.Fatalf("Times of UsecasesMock.Return mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReturn.expectedInvocations, n)
	mmReturn.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReturn
}

func (mmReturn *mUsecasesMockReturn) invocationsDone() bool {
	if len(mmReturn.expectations) == 0 && mmReturn.defaultExpectation == nil && mmReturn.mock.funcReturn == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReturn.mock.afterReturnCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReturn.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Return implements mm_manager_service.Usecases
func (mmReturn *UsecasesMock) Return(req *dto.ReturnRequest) (err error) {
	mm_atomic.AddUint64(&mmReturn.beforeReturnCounter, 1)
	defer mm_atomic.AddUint64(&mmReturn.afterReturnCounter, 1)

	mmReturn.t.Helper()

	if mmReturn.inspectFuncReturn != nil {
		mmReturn.inspectFuncReturn(req)
	}

	mm_params := UsecasesMockReturnParams{req}

	// Record call args
	mmReturn.ReturnMock.mutex.Lock()
	mmReturn.ReturnMock.callArgs = append(mmReturn.ReturnMock.callArgs, &mm_params)
	mmReturn.ReturnMock.mutex.Unlock()

	for _, e := range mmReturn.ReturnMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReturn.ReturnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReturn.ReturnMock.defaultExpectation.Counter, 1)
		mm_want := mmReturn.ReturnMock.defaultExpectation.params
		mm_want_ptrs := mmReturn.ReturnMock.defaultExpectation.paramPtrs

		mm_got := UsecasesMockReturnParams{req}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmReturn.t.Errorf("UsecasesMock.Return got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReturn.ReturnMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReturn.t.Errorf("UsecasesMock.Return got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReturn.ReturnMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReturn.ReturnMock.defaultExpectation.results
		if mm_results == nil {
			mmReturn.t.Fatal("No results are set for the UsecasesMock.Return")
		}
		return (*mm_results).err
	}
	if mmReturn.funcReturn != nil {
		return mmReturn.funcReturn(req)
	}
	mmReturn.t.Fatalf("Unexpected call to UsecasesMock.Return. %v", req)
	return
}

// ReturnAfterCounter returns a count of finished UsecasesMock.Return invocations
func (mmReturn *UsecasesMock) ReturnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReturn.afterReturnCounter)
}

// ReturnBeforeCounter returns a count of UsecasesMock.Return invocations
func (mmReturn *UsecasesMock) ReturnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReturn.beforeReturnCounter)
}

// Calls returns a list of arguments used in each call to UsecasesMock.Return.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReturn *mUsecasesMockReturn) Calls() []*UsecasesMockReturnParams {
	mmReturn.mutex.RLock()

	argCopy := make([]*UsecasesMockReturnParams, len(mmReturn.callArgs))
	copy(argCopy, mmReturn.callArgs)

	mmReturn.mutex.RUnlock()

	return argCopy
}

// MinimockReturnDone returns true if the count of the Return invocations corresponds
// the number of defined expectations
func (m *UsecasesMock) MinimockReturnDone() bool {
	if m.ReturnMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReturnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReturnMock.invocationsDone()
}

// MinimockReturnInspect logs each unmet expectation
func (m *UsecasesMock) MinimockReturnInspect() {
	for _, e := range m.ReturnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UsecasesMock.Return at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReturnCounter := mm_atomic.LoadUint64(&m.afterReturnCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReturnMock.defaultExpectation != nil && afterReturnCounter < 1 {
		if m.ReturnMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UsecasesMock.Return at\n%s", m.ReturnMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UsecasesMock.Return at\n%s with params: %#v", m.ReturnMock.defaultExpectation.expectationOrigins.origin, *m.ReturnMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReturn != nil && afterReturnCounter < 1 {
		m.t.Errorf("Expected call to UsecasesMock.Return at\n%s", m.funcReturnOrigin)
	}

	if !m.ReturnMock.invocationsDone() && afterReturnCounter > 0 {
		m.t.Errorf("Expected %d calls to UsecasesMock.Return at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReturnMock.expectedInvocations), m.ReturnMock.expectedInvocationsOrigin, afterReturnCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UsecasesMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAcceptOrderInspect()

			m.MinimockAcceptRefundInspect()

			m.MinimockGetOrdersInspect()

			m.MinimockGetRefundsInspect()

			m.MinimockGiveInspect()

			m.MinimockReturnInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UsecasesMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UsecasesMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAcceptOrderDone() &&
		m.MinimockAcceptRefundDone() &&
		m.MinimockGetOrdersDone() &&
		m.MinimockGetRefundsDone() &&
		m.MinimockGiveDone() &&
		m.MinimockReturnDone()
}
