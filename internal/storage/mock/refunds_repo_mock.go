// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mock

//go:generate minimock -i gitlab.ozon.dev/chppppr/homework/internal/storage.RefundsRepository -o refunds_repo.go -n RefundsRepositoryMock -p mock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.ozon.dev/chppppr/homework/internal/domain"
)

// RefundsRepositoryMock implements mm_storage.RefundsRepository
type RefundsRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddRefund          func(userID uint64, orderID uint64, order *domain.Order) (err error)
	funcAddRefundOrigin    string
	inspectFuncAddRefund   func(userID uint64, orderID uint64, order *domain.Order)
	afterAddRefundCounter  uint64
	beforeAddRefundCounter uint64
	AddRefundMock          mRefundsRepositoryMockAddRefund

	funcGetRefunds          func(pageID uint64, ordersPerPage uint64) (oa1 []domain.OrderView, err error)
	funcGetRefundsOrigin    string
	inspectFuncGetRefunds   func(pageID uint64, ordersPerPage uint64)
	afterGetRefundsCounter  uint64
	beforeGetRefundsCounter uint64
	GetRefundsMock          mRefundsRepositoryMockGetRefunds

	funcRemoveRefund          func(orderID uint64) (err error)
	funcRemoveRefundOrigin    string
	inspectFuncRemoveRefund   func(orderID uint64)
	afterRemoveRefundCounter  uint64
	beforeRemoveRefundCounter uint64
	RemoveRefundMock          mRefundsRepositoryMockRemoveRefund
}

// NewRefundsRepositoryMock returns a mock for mm_storage.RefundsRepository
func NewRefundsRepositoryMock(t minimock.Tester) *RefundsRepositoryMock {
	m := &RefundsRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddRefundMock = mRefundsRepositoryMockAddRefund{mock: m}
	m.AddRefundMock.callArgs = []*RefundsRepositoryMockAddRefundParams{}

	m.GetRefundsMock = mRefundsRepositoryMockGetRefunds{mock: m}
	m.GetRefundsMock.callArgs = []*RefundsRepositoryMockGetRefundsParams{}

	m.RemoveRefundMock = mRefundsRepositoryMockRemoveRefund{mock: m}
	m.RemoveRefundMock.callArgs = []*RefundsRepositoryMockRemoveRefundParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRefundsRepositoryMockAddRefund struct {
	optional           bool
	mock               *RefundsRepositoryMock
	defaultExpectation *RefundsRepositoryMockAddRefundExpectation
	expectations       []*RefundsRepositoryMockAddRefundExpectation

	callArgs []*RefundsRepositoryMockAddRefundParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RefundsRepositoryMockAddRefundExpectation specifies expectation struct of the RefundsRepository.AddRefund
type RefundsRepositoryMockAddRefundExpectation struct {
	mock               *RefundsRepositoryMock
	params             *RefundsRepositoryMockAddRefundParams
	paramPtrs          *RefundsRepositoryMockAddRefundParamPtrs
	expectationOrigins RefundsRepositoryMockAddRefundExpectationOrigins
	results            *RefundsRepositoryMockAddRefundResults
	returnOrigin       string
	Counter            uint64
}

// RefundsRepositoryMockAddRefundParams contains parameters of the RefundsRepository.AddRefund
type RefundsRepositoryMockAddRefundParams struct {
	userID  uint64
	orderID uint64
	order   *domain.Order
}

// RefundsRepositoryMockAddRefundParamPtrs contains pointers to parameters of the RefundsRepository.AddRefund
type RefundsRepositoryMockAddRefundParamPtrs struct {
	userID  *uint64
	orderID *uint64
	order   **domain.Order
}

// RefundsRepositoryMockAddRefundResults contains results of the RefundsRepository.AddRefund
type RefundsRepositoryMockAddRefundResults struct {
	err error
}

// RefundsRepositoryMockAddRefundOrigins contains origins of expectations of the RefundsRepository.AddRefund
type RefundsRepositoryMockAddRefundExpectationOrigins struct {
	origin        string
	originUserID  string
	originOrderID string
	originOrder   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddRefund *mRefundsRepositoryMockAddRefund) Optional() *mRefundsRepositoryMockAddRefund {
	mmAddRefund.optional = true
	return mmAddRefund
}

// Expect sets up expected params for RefundsRepository.AddRefund
func (mmAddRefund *mRefundsRepositoryMockAddRefund) Expect(userID uint64, orderID uint64, order *domain.Order) *mRefundsRepositoryMockAddRefund {
	if mmAddRefund.mock.funcAddRefund != nil {
		mmAddRefund.mock.t.Fatalf("RefundsRepositoryMock.AddRefund mock is already set by Set")
	}

	if mmAddRefund.defaultExpectation == nil {
		mmAddRefund.defaultExpectation = &RefundsRepositoryMockAddRefundExpectation{}
	}

	if mmAddRefund.defaultExpectation.paramPtrs != nil {
		mmAddRefund.mock.t.Fatalf("RefundsRepositoryMock.AddRefund mock is already set by ExpectParams functions")
	}

	mmAddRefund.defaultExpectation.params = &RefundsRepositoryMockAddRefundParams{userID, orderID, order}
	mmAddRefund.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddRefund.expectations {
		if minimock.Equal(e.params, mmAddRefund.defaultExpectation.params) {
			mmAddRefund.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddRefund.defaultExpectation.params)
		}
	}

	return mmAddRefund
}

// ExpectUserIDParam1 sets up expected param userID for RefundsRepository.AddRefund
func (mmAddRefund *mRefundsRepositoryMockAddRefund) ExpectUserIDParam1(userID uint64) *mRefundsRepositoryMockAddRefund {
	if mmAddRefund.mock.funcAddRefund != nil {
		mmAddRefund.mock.t.Fatalf("RefundsRepositoryMock.AddRefund mock is already set by Set")
	}

	if mmAddRefund.defaultExpectation == nil {
		mmAddRefund.defaultExpectation = &RefundsRepositoryMockAddRefundExpectation{}
	}

	if mmAddRefund.defaultExpectation.params != nil {
		mmAddRefund.mock.t.Fatalf("RefundsRepositoryMock.AddRefund mock is already set by Expect")
	}

	if mmAddRefund.defaultExpectation.paramPtrs == nil {
		mmAddRefund.defaultExpectation.paramPtrs = &RefundsRepositoryMockAddRefundParamPtrs{}
	}
	mmAddRefund.defaultExpectation.paramPtrs.userID = &userID
	mmAddRefund.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmAddRefund
}

// ExpectOrderIDParam2 sets up expected param orderID for RefundsRepository.AddRefund
func (mmAddRefund *mRefundsRepositoryMockAddRefund) ExpectOrderIDParam2(orderID uint64) *mRefundsRepositoryMockAddRefund {
	if mmAddRefund.mock.funcAddRefund != nil {
		mmAddRefund.mock.t.Fatalf("RefundsRepositoryMock.AddRefund mock is already set by Set")
	}

	if mmAddRefund.defaultExpectation == nil {
		mmAddRefund.defaultExpectation = &RefundsRepositoryMockAddRefundExpectation{}
	}

	if mmAddRefund.defaultExpectation.params != nil {
		mmAddRefund.mock.t.Fatalf("RefundsRepositoryMock.AddRefund mock is already set by Expect")
	}

	if mmAddRefund.defaultExpectation.paramPtrs == nil {
		mmAddRefund.defaultExpectation.paramPtrs = &RefundsRepositoryMockAddRefundParamPtrs{}
	}
	mmAddRefund.defaultExpectation.paramPtrs.orderID = &orderID
	mmAddRefund.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmAddRefund
}

// ExpectOrderParam3 sets up expected param order for RefundsRepository.AddRefund
func (mmAddRefund *mRefundsRepositoryMockAddRefund) ExpectOrderParam3(order *domain.Order) *mRefundsRepositoryMockAddRefund {
	if mmAddRefund.mock.funcAddRefund != nil {
		mmAddRefund.mock.t.Fatalf("RefundsRepositoryMock.AddRefund mock is already set by Set")
	}

	if mmAddRefund.defaultExpectation == nil {
		mmAddRefund.defaultExpectation = &RefundsRepositoryMockAddRefundExpectation{}
	}

	if mmAddRefund.defaultExpectation.params != nil {
		mmAddRefund.mock.t.Fatalf("RefundsRepositoryMock.AddRefund mock is already set by Expect")
	}

	if mmAddRefund.defaultExpectation.paramPtrs == nil {
		mmAddRefund.defaultExpectation.paramPtrs = &RefundsRepositoryMockAddRefundParamPtrs{}
	}
	mmAddRefund.defaultExpectation.paramPtrs.order = &order
	mmAddRefund.defaultExpectation.expectationOrigins.originOrder = minimock.CallerInfo(1)

	return mmAddRefund
}

// Inspect accepts an inspector function that has same arguments as the RefundsRepository.AddRefund
func (mmAddRefund *mRefundsRepositoryMockAddRefund) Inspect(f func(userID uint64, orderID uint64, order *domain.Order)) *mRefundsRepositoryMockAddRefund {
	if mmAddRefund.mock.inspectFuncAddRefund != nil {
		mmAddRefund.mock.t.Fatalf("Inspect function is already set for RefundsRepositoryMock.AddRefund")
	}

	mmAddRefund.mock.inspectFuncAddRefund = f

	return mmAddRefund
}

// Return sets up results that will be returned by RefundsRepository.AddRefund
func (mmAddRefund *mRefundsRepositoryMockAddRefund) Return(err error) *RefundsRepositoryMock {
	if mmAddRefund.mock.funcAddRefund != nil {
		mmAddRefund.mock.t.Fatalf("RefundsRepositoryMock.AddRefund mock is already set by Set")
	}

	if mmAddRefund.defaultExpectation == nil {
		mmAddRefund.defaultExpectation = &RefundsRepositoryMockAddRefundExpectation{mock: mmAddRefund.mock}
	}
	mmAddRefund.defaultExpectation.results = &RefundsRepositoryMockAddRefundResults{err}
	mmAddRefund.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddRefund.mock
}

// Set uses given function f to mock the RefundsRepository.AddRefund method
func (mmAddRefund *mRefundsRepositoryMockAddRefund) Set(f func(userID uint64, orderID uint64, order *domain.Order) (err error)) *RefundsRepositoryMock {
	if mmAddRefund.defaultExpectation != nil {
		mmAddRefund.mock.t.Fatalf("Default expectation is already set for the RefundsRepository.AddRefund method")
	}

	if len(mmAddRefund.expectations) > 0 {
		mmAddRefund.mock.t.Fatalf("Some expectations are already set for the RefundsRepository.AddRefund method")
	}

	mmAddRefund.mock.funcAddRefund = f
	mmAddRefund.mock.funcAddRefundOrigin = minimock.CallerInfo(1)
	return mmAddRefund.mock
}

// When sets expectation for the RefundsRepository.AddRefund which will trigger the result defined by the following
// Then helper
func (mmAddRefund *mRefundsRepositoryMockAddRefund) When(userID uint64, orderID uint64, order *domain.Order) *RefundsRepositoryMockAddRefundExpectation {
	if mmAddRefund.mock.funcAddRefund != nil {
		mmAddRefund.mock.t.Fatalf("RefundsRepositoryMock.AddRefund mock is already set by Set")
	}

	expectation := &RefundsRepositoryMockAddRefundExpectation{
		mock:               mmAddRefund.mock,
		params:             &RefundsRepositoryMockAddRefundParams{userID, orderID, order},
		expectationOrigins: RefundsRepositoryMockAddRefundExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddRefund.expectations = append(mmAddRefund.expectations, expectation)
	return expectation
}

// Then sets up RefundsRepository.AddRefund return parameters for the expectation previously defined by the When method
func (e *RefundsRepositoryMockAddRefundExpectation) Then(err error) *RefundsRepositoryMock {
	e.results = &RefundsRepositoryMockAddRefundResults{err}
	return e.mock
}

// Times sets number of times RefundsRepository.AddRefund should be invoked
func (mmAddRefund *mRefundsRepositoryMockAddRefund) Times(n uint64) *mRefundsRepositoryMockAddRefund {
	if n == 0 {
		mmAddRefund.mock.t.Fatalf("Times of RefundsRepositoryMock.AddRefund mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddRefund.expectedInvocations, n)
	mmAddRefund.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddRefund
}

func (mmAddRefund *mRefundsRepositoryMockAddRefund) invocationsDone() bool {
	if len(mmAddRefund.expectations) == 0 && mmAddRefund.defaultExpectation == nil && mmAddRefund.mock.funcAddRefund == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddRefund.mock.afterAddRefundCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddRefund.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddRefund implements mm_storage.RefundsRepository
func (mmAddRefund *RefundsRepositoryMock) AddRefund(userID uint64, orderID uint64, order *domain.Order) (err error) {
	mm_atomic.AddUint64(&mmAddRefund.beforeAddRefundCounter, 1)
	defer mm_atomic.AddUint64(&mmAddRefund.afterAddRefundCounter, 1)

	mmAddRefund.t.Helper()

	if mmAddRefund.inspectFuncAddRefund != nil {
		mmAddRefund.inspectFuncAddRefund(userID, orderID, order)
	}

	mm_params := RefundsRepositoryMockAddRefundParams{userID, orderID, order}

	// Record call args
	mmAddRefund.AddRefundMock.mutex.Lock()
	mmAddRefund.AddRefundMock.callArgs = append(mmAddRefund.AddRefundMock.callArgs, &mm_params)
	mmAddRefund.AddRefundMock.mutex.Unlock()

	for _, e := range mmAddRefund.AddRefundMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddRefund.AddRefundMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddRefund.AddRefundMock.defaultExpectation.Counter, 1)
		mm_want := mmAddRefund.AddRefundMock.defaultExpectation.params
		mm_want_ptrs := mmAddRefund.AddRefundMock.defaultExpectation.paramPtrs

		mm_got := RefundsRepositoryMockAddRefundParams{userID, orderID, order}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmAddRefund.t.Errorf("RefundsRepositoryMock.AddRefund got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddRefund.AddRefundMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmAddRefund.t.Errorf("RefundsRepositoryMock.AddRefund got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddRefund.AddRefundMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmAddRefund.t.Errorf("RefundsRepositoryMock.AddRefund got unexpected parameter order, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddRefund.AddRefundMock.defaultExpectation.expectationOrigins.originOrder, *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddRefund.t.Errorf("RefundsRepositoryMock.AddRefund got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddRefund.AddRefundMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddRefund.AddRefundMock.defaultExpectation.results
		if mm_results == nil {
			mmAddRefund.t.Fatal("No results are set for the RefundsRepositoryMock.AddRefund")
		}
		return (*mm_results).err
	}
	if mmAddRefund.funcAddRefund != nil {
		return mmAddRefund.funcAddRefund(userID, orderID, order)
	}
	mmAddRefund.t.Fatalf("Unexpected call to RefundsRepositoryMock.AddRefund. %v %v %v", userID, orderID, order)
	return
}

// AddRefundAfterCounter returns a count of finished RefundsRepositoryMock.AddRefund invocations
func (mmAddRefund *RefundsRepositoryMock) AddRefundAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddRefund.afterAddRefundCounter)
}

// AddRefundBeforeCounter returns a count of RefundsRepositoryMock.AddRefund invocations
func (mmAddRefund *RefundsRepositoryMock) AddRefundBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddRefund.beforeAddRefundCounter)
}

// Calls returns a list of arguments used in each call to RefundsRepositoryMock.AddRefund.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddRefund *mRefundsRepositoryMockAddRefund) Calls() []*RefundsRepositoryMockAddRefundParams {
	mmAddRefund.mutex.RLock()

	argCopy := make([]*RefundsRepositoryMockAddRefundParams, len(mmAddRefund.callArgs))
	copy(argCopy, mmAddRefund.callArgs)

	mmAddRefund.mutex.RUnlock()

	return argCopy
}

// MinimockAddRefundDone returns true if the count of the AddRefund invocations corresponds
// the number of defined expectations
func (m *RefundsRepositoryMock) MinimockAddRefundDone() bool {
	if m.AddRefundMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddRefundMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddRefundMock.invocationsDone()
}

// MinimockAddRefundInspect logs each unmet expectation
func (m *RefundsRepositoryMock) MinimockAddRefundInspect() {
	for _, e := range m.AddRefundMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RefundsRepositoryMock.AddRefund at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddRefundCounter := mm_atomic.LoadUint64(&m.afterAddRefundCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddRefundMock.defaultExpectation != nil && afterAddRefundCounter < 1 {
		if m.AddRefundMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RefundsRepositoryMock.AddRefund at\n%s", m.AddRefundMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RefundsRepositoryMock.AddRefund at\n%s with params: %#v", m.AddRefundMock.defaultExpectation.expectationOrigins.origin, *m.AddRefundMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddRefund != nil && afterAddRefundCounter < 1 {
		m.t.Errorf("Expected call to RefundsRepositoryMock.AddRefund at\n%s", m.funcAddRefundOrigin)
	}

	if !m.AddRefundMock.invocationsDone() && afterAddRefundCounter > 0 {
		m.t.Errorf("Expected %d calls to RefundsRepositoryMock.AddRefund at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddRefundMock.expectedInvocations), m.AddRefundMock.expectedInvocationsOrigin, afterAddRefundCounter)
	}
}

type mRefundsRepositoryMockGetRefunds struct {
	optional           bool
	mock               *RefundsRepositoryMock
	defaultExpectation *RefundsRepositoryMockGetRefundsExpectation
	expectations       []*RefundsRepositoryMockGetRefundsExpectation

	callArgs []*RefundsRepositoryMockGetRefundsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RefundsRepositoryMockGetRefundsExpectation specifies expectation struct of the RefundsRepository.GetRefunds
type RefundsRepositoryMockGetRefundsExpectation struct {
	mock               *RefundsRepositoryMock
	params             *RefundsRepositoryMockGetRefundsParams
	paramPtrs          *RefundsRepositoryMockGetRefundsParamPtrs
	expectationOrigins RefundsRepositoryMockGetRefundsExpectationOrigins
	results            *RefundsRepositoryMockGetRefundsResults
	returnOrigin       string
	Counter            uint64
}

// RefundsRepositoryMockGetRefundsParams contains parameters of the RefundsRepository.GetRefunds
type RefundsRepositoryMockGetRefundsParams struct {
	pageID        uint64
	ordersPerPage uint64
}

// RefundsRepositoryMockGetRefundsParamPtrs contains pointers to parameters of the RefundsRepository.GetRefunds
type RefundsRepositoryMockGetRefundsParamPtrs struct {
	pageID        *uint64
	ordersPerPage *uint64
}

// RefundsRepositoryMockGetRefundsResults contains results of the RefundsRepository.GetRefunds
type RefundsRepositoryMockGetRefundsResults struct {
	oa1 []domain.OrderView
	err error
}

// RefundsRepositoryMockGetRefundsOrigins contains origins of expectations of the RefundsRepository.GetRefunds
type RefundsRepositoryMockGetRefundsExpectationOrigins struct {
	origin              string
	originPageID        string
	originOrdersPerPage string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetRefunds *mRefundsRepositoryMockGetRefunds) Optional() *mRefundsRepositoryMockGetRefunds {
	mmGetRefunds.optional = true
	return mmGetRefunds
}

// Expect sets up expected params for RefundsRepository.GetRefunds
func (mmGetRefunds *mRefundsRepositoryMockGetRefunds) Expect(pageID uint64, ordersPerPage uint64) *mRefundsRepositoryMockGetRefunds {
	if mmGetRefunds.mock.funcGetRefunds != nil {
		mmGetRefunds.mock.t.Fatalf("RefundsRepositoryMock.GetRefunds mock is already set by Set")
	}

	if mmGetRefunds.defaultExpectation == nil {
		mmGetRefunds.defaultExpectation = &RefundsRepositoryMockGetRefundsExpectation{}
	}

	if mmGetRefunds.defaultExpectation.paramPtrs != nil {
		mmGetRefunds.mock.t.Fatalf("RefundsRepositoryMock.GetRefunds mock is already set by ExpectParams functions")
	}

	mmGetRefunds.defaultExpectation.params = &RefundsRepositoryMockGetRefundsParams{pageID, ordersPerPage}
	mmGetRefunds.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetRefunds.expectations {
		if minimock.Equal(e.params, mmGetRefunds.defaultExpectation.params) {
			mmGetRefunds.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRefunds.defaultExpectation.params)
		}
	}

	return mmGetRefunds
}

// ExpectPageIDParam1 sets up expected param pageID for RefundsRepository.GetRefunds
func (mmGetRefunds *mRefundsRepositoryMockGetRefunds) ExpectPageIDParam1(pageID uint64) *mRefundsRepositoryMockGetRefunds {
	if mmGetRefunds.mock.funcGetRefunds != nil {
		mmGetRefunds.mock.t.Fatalf("RefundsRepositoryMock.GetRefunds mock is already set by Set")
	}

	if mmGetRefunds.defaultExpectation == nil {
		mmGetRefunds.defaultExpectation = &RefundsRepositoryMockGetRefundsExpectation{}
	}

	if mmGetRefunds.defaultExpectation.params != nil {
		mmGetRefunds.mock.t.Fatalf("RefundsRepositoryMock.GetRefunds mock is already set by Expect")
	}

	if mmGetRefunds.defaultExpectation.paramPtrs == nil {
		mmGetRefunds.defaultExpectation.paramPtrs = &RefundsRepositoryMockGetRefundsParamPtrs{}
	}
	mmGetRefunds.defaultExpectation.paramPtrs.pageID = &pageID
	mmGetRefunds.defaultExpectation.expectationOrigins.originPageID = minimock.CallerInfo(1)

	return mmGetRefunds
}

// ExpectOrdersPerPageParam2 sets up expected param ordersPerPage for RefundsRepository.GetRefunds
func (mmGetRefunds *mRefundsRepositoryMockGetRefunds) ExpectOrdersPerPageParam2(ordersPerPage uint64) *mRefundsRepositoryMockGetRefunds {
	if mmGetRefunds.mock.funcGetRefunds != nil {
		mmGetRefunds.mock.t.Fatalf("RefundsRepositoryMock.GetRefunds mock is already set by Set")
	}

	if mmGetRefunds.defaultExpectation == nil {
		mmGetRefunds.defaultExpectation = &RefundsRepositoryMockGetRefundsExpectation{}
	}

	if mmGetRefunds.defaultExpectation.params != nil {
		mmGetRefunds.mock.t.Fatalf("RefundsRepositoryMock.GetRefunds mock is already set by Expect")
	}

	if mmGetRefunds.defaultExpectation.paramPtrs == nil {
		mmGetRefunds.defaultExpectation.paramPtrs = &RefundsRepositoryMockGetRefundsParamPtrs{}
	}
	mmGetRefunds.defaultExpectation.paramPtrs.ordersPerPage = &ordersPerPage
	mmGetRefunds.defaultExpectation.expectationOrigins.originOrdersPerPage = minimock.CallerInfo(1)

	return mmGetRefunds
}

// Inspect accepts an inspector function that has same arguments as the RefundsRepository.GetRefunds
func (mmGetRefunds *mRefundsRepositoryMockGetRefunds) Inspect(f func(pageID uint64, ordersPerPage uint64)) *mRefundsRepositoryMockGetRefunds {
	if mmGetRefunds.mock.inspectFuncGetRefunds != nil {
		mmGetRefunds.mock.t.Fatalf("Inspect function is already set for RefundsRepositoryMock.GetRefunds")
	}

	mmGetRefunds.mock.inspectFuncGetRefunds = f

	return mmGetRefunds
}

// Return sets up results that will be returned by RefundsRepository.GetRefunds
func (mmGetRefunds *mRefundsRepositoryMockGetRefunds) Return(oa1 []domain.OrderView, err error) *RefundsRepositoryMock {
	if mmGetRefunds.mock.funcGetRefunds != nil {
		mmGetRefunds.mock.t.Fatalf("RefundsRepositoryMock.GetRefunds mock is already set by Set")
	}

	if mmGetRefunds.defaultExpectation == nil {
		mmGetRefunds.defaultExpectation = &RefundsRepositoryMockGetRefundsExpectation{mock: mmGetRefunds.mock}
	}
	mmGetRefunds.defaultExpectation.results = &RefundsRepositoryMockGetRefundsResults{oa1, err}
	mmGetRefunds.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetRefunds.mock
}

// Set uses given function f to mock the RefundsRepository.GetRefunds method
func (mmGetRefunds *mRefundsRepositoryMockGetRefunds) Set(f func(pageID uint64, ordersPerPage uint64) (oa1 []domain.OrderView, err error)) *RefundsRepositoryMock {
	if mmGetRefunds.defaultExpectation != nil {
		mmGetRefunds.mock.t.Fatalf("Default expectation is already set for the RefundsRepository.GetRefunds method")
	}

	if len(mmGetRefunds.expectations) > 0 {
		mmGetRefunds.mock.t.Fatalf("Some expectations are already set for the RefundsRepository.GetRefunds method")
	}

	mmGetRefunds.mock.funcGetRefunds = f
	mmGetRefunds.mock.funcGetRefundsOrigin = minimock.CallerInfo(1)
	return mmGetRefunds.mock
}

// When sets expectation for the RefundsRepository.GetRefunds which will trigger the result defined by the following
// Then helper
func (mmGetRefunds *mRefundsRepositoryMockGetRefunds) When(pageID uint64, ordersPerPage uint64) *RefundsRepositoryMockGetRefundsExpectation {
	if mmGetRefunds.mock.funcGetRefunds != nil {
		mmGetRefunds.mock.t.Fatalf("RefundsRepositoryMock.GetRefunds mock is already set by Set")
	}

	expectation := &RefundsRepositoryMockGetRefundsExpectation{
		mock:               mmGetRefunds.mock,
		params:             &RefundsRepositoryMockGetRefundsParams{pageID, ordersPerPage},
		expectationOrigins: RefundsRepositoryMockGetRefundsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetRefunds.expectations = append(mmGetRefunds.expectations, expectation)
	return expectation
}

// Then sets up RefundsRepository.GetRefunds return parameters for the expectation previously defined by the When method
func (e *RefundsRepositoryMockGetRefundsExpectation) Then(oa1 []domain.OrderView, err error) *RefundsRepositoryMock {
	e.results = &RefundsRepositoryMockGetRefundsResults{oa1, err}
	return e.mock
}

// Times sets number of times RefundsRepository.GetRefunds should be invoked
func (mmGetRefunds *mRefundsRepositoryMockGetRefunds) Times(n uint64) *mRefundsRepositoryMockGetRefunds {
	if n == 0 {
		mmGetRefunds.mock.t.Fatalf("Times of RefundsRepositoryMock.GetRefunds mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetRefunds.expectedInvocations, n)
	mmGetRefunds.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetRefunds
}

func (mmGetRefunds *mRefundsRepositoryMockGetRefunds) invocationsDone() bool {
	if len(mmGetRefunds.expectations) == 0 && mmGetRefunds.defaultExpectation == nil && mmGetRefunds.mock.funcGetRefunds == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetRefunds.mock.afterGetRefundsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetRefunds.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetRefunds implements mm_storage.RefundsRepository
func (mmGetRefunds *RefundsRepositoryMock) GetRefunds(pageID uint64, ordersPerPage uint64) (oa1 []domain.OrderView, err error) {
	mm_atomic.AddUint64(&mmGetRefunds.beforeGetRefundsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRefunds.afterGetRefundsCounter, 1)

	mmGetRefunds.t.Helper()

	if mmGetRefunds.inspectFuncGetRefunds != nil {
		mmGetRefunds.inspectFuncGetRefunds(pageID, ordersPerPage)
	}

	mm_params := RefundsRepositoryMockGetRefundsParams{pageID, ordersPerPage}

	// Record call args
	mmGetRefunds.GetRefundsMock.mutex.Lock()
	mmGetRefunds.GetRefundsMock.callArgs = append(mmGetRefunds.GetRefundsMock.callArgs, &mm_params)
	mmGetRefunds.GetRefundsMock.mutex.Unlock()

	for _, e := range mmGetRefunds.GetRefundsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.err
		}
	}

	if mmGetRefunds.GetRefundsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRefunds.GetRefundsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRefunds.GetRefundsMock.defaultExpectation.params
		mm_want_ptrs := mmGetRefunds.GetRefundsMock.defaultExpectation.paramPtrs

		mm_got := RefundsRepositoryMockGetRefundsParams{pageID, ordersPerPage}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.pageID != nil && !minimock.Equal(*mm_want_ptrs.pageID, mm_got.pageID) {
				mmGetRefunds.t.Errorf("RefundsRepositoryMock.GetRefunds got unexpected parameter pageID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetRefunds.GetRefundsMock.defaultExpectation.expectationOrigins.originPageID, *mm_want_ptrs.pageID, mm_got.pageID, minimock.Diff(*mm_want_ptrs.pageID, mm_got.pageID))
			}

			if mm_want_ptrs.ordersPerPage != nil && !minimock.Equal(*mm_want_ptrs.ordersPerPage, mm_got.ordersPerPage) {
				mmGetRefunds.t.Errorf("RefundsRepositoryMock.GetRefunds got unexpected parameter ordersPerPage, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetRefunds.GetRefundsMock.defaultExpectation.expectationOrigins.originOrdersPerPage, *mm_want_ptrs.ordersPerPage, mm_got.ordersPerPage, minimock.Diff(*mm_want_ptrs.ordersPerPage, mm_got.ordersPerPage))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRefunds.t.Errorf("RefundsRepositoryMock.GetRefunds got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetRefunds.GetRefundsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRefunds.GetRefundsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRefunds.t.Fatal("No results are set for the RefundsRepositoryMock.GetRefunds")
		}
		return (*mm_results).oa1, (*mm_results).err
	}
	if mmGetRefunds.funcGetRefunds != nil {
		return mmGetRefunds.funcGetRefunds(pageID, ordersPerPage)
	}
	mmGetRefunds.t.Fatalf("Unexpected call to RefundsRepositoryMock.GetRefunds. %v %v", pageID, ordersPerPage)
	return
}

// GetRefundsAfterCounter returns a count of finished RefundsRepositoryMock.GetRefunds invocations
func (mmGetRefunds *RefundsRepositoryMock) GetRefundsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRefunds.afterGetRefundsCounter)
}

// GetRefundsBeforeCounter returns a count of RefundsRepositoryMock.GetRefunds invocations
func (mmGetRefunds *RefundsRepositoryMock) GetRefundsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRefunds.beforeGetRefundsCounter)
}

// Calls returns a list of arguments used in each call to RefundsRepositoryMock.GetRefunds.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRefunds *mRefundsRepositoryMockGetRefunds) Calls() []*RefundsRepositoryMockGetRefundsParams {
	mmGetRefunds.mutex.RLock()

	argCopy := make([]*RefundsRepositoryMockGetRefundsParams, len(mmGetRefunds.callArgs))
	copy(argCopy, mmGetRefunds.callArgs)

	mmGetRefunds.mutex.RUnlock()

	return argCopy
}

// MinimockGetRefundsDone returns true if the count of the GetRefunds invocations corresponds
// the number of defined expectations
func (m *RefundsRepositoryMock) MinimockGetRefundsDone() bool {
	if m.GetRefundsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetRefundsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetRefundsMock.invocationsDone()
}

// MinimockGetRefundsInspect logs each unmet expectation
func (m *RefundsRepositoryMock) MinimockGetRefundsInspect() {
	for _, e := range m.GetRefundsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RefundsRepositoryMock.GetRefunds at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetRefundsCounter := mm_atomic.LoadUint64(&m.afterGetRefundsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetRefundsMock.defaultExpectation != nil && afterGetRefundsCounter < 1 {
		if m.GetRefundsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RefundsRepositoryMock.GetRefunds at\n%s", m.GetRefundsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RefundsRepositoryMock.GetRefunds at\n%s with params: %#v", m.GetRefundsMock.defaultExpectation.expectationOrigins.origin, *m.GetRefundsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRefunds != nil && afterGetRefundsCounter < 1 {
		m.t.Errorf("Expected call to RefundsRepositoryMock.GetRefunds at\n%s", m.funcGetRefundsOrigin)
	}

	if !m.GetRefundsMock.invocationsDone() && afterGetRefundsCounter > 0 {
		m.t.Errorf("Expected %d calls to RefundsRepositoryMock.GetRefunds at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetRefundsMock.expectedInvocations), m.GetRefundsMock.expectedInvocationsOrigin, afterGetRefundsCounter)
	}
}

type mRefundsRepositoryMockRemoveRefund struct {
	optional           bool
	mock               *RefundsRepositoryMock
	defaultExpectation *RefundsRepositoryMockRemoveRefundExpectation
	expectations       []*RefundsRepositoryMockRemoveRefundExpectation

	callArgs []*RefundsRepositoryMockRemoveRefundParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RefundsRepositoryMockRemoveRefundExpectation specifies expectation struct of the RefundsRepository.RemoveRefund
type RefundsRepositoryMockRemoveRefundExpectation struct {
	mock               *RefundsRepositoryMock
	params             *RefundsRepositoryMockRemoveRefundParams
	paramPtrs          *RefundsRepositoryMockRemoveRefundParamPtrs
	expectationOrigins RefundsRepositoryMockRemoveRefundExpectationOrigins
	results            *RefundsRepositoryMockRemoveRefundResults
	returnOrigin       string
	Counter            uint64
}

// RefundsRepositoryMockRemoveRefundParams contains parameters of the RefundsRepository.RemoveRefund
type RefundsRepositoryMockRemoveRefundParams struct {
	orderID uint64
}

// RefundsRepositoryMockRemoveRefundParamPtrs contains pointers to parameters of the RefundsRepository.RemoveRefund
type RefundsRepositoryMockRemoveRefundParamPtrs struct {
	orderID *uint64
}

// RefundsRepositoryMockRemoveRefundResults contains results of the RefundsRepository.RemoveRefund
type RefundsRepositoryMockRemoveRefundResults struct {
	err error
}

// RefundsRepositoryMockRemoveRefundOrigins contains origins of expectations of the RefundsRepository.RemoveRefund
type RefundsRepositoryMockRemoveRefundExpectationOrigins struct {
	origin        string
	originOrderID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemoveRefund *mRefundsRepositoryMockRemoveRefund) Optional() *mRefundsRepositoryMockRemoveRefund {
	mmRemoveRefund.optional = true
	return mmRemoveRefund
}

// Expect sets up expected params for RefundsRepository.RemoveRefund
func (mmRemoveRefund *mRefundsRepositoryMockRemoveRefund) Expect(orderID uint64) *mRefundsRepositoryMockRemoveRefund {
	if mmRemoveRefund.mock.funcRemoveRefund != nil {
		mmRemoveRefund.mock.t.Fatalf("RefundsRepositoryMock.RemoveRefund mock is already set by Set")
	}

	if mmRemoveRefund.defaultExpectation == nil {
		mmRemoveRefund.defaultExpectation = &RefundsRepositoryMockRemoveRefundExpectation{}
	}

	if mmRemoveRefund.defaultExpectation.paramPtrs != nil {
		mmRemoveRefund.mock.t.Fatalf("RefundsRepositoryMock.RemoveRefund mock is already set by ExpectParams functions")
	}

	mmRemoveRefund.defaultExpectation.params = &RefundsRepositoryMockRemoveRefundParams{orderID}
	mmRemoveRefund.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRemoveRefund.expectations {
		if minimock.Equal(e.params, mmRemoveRefund.defaultExpectation.params) {
			mmRemoveRefund.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveRefund.defaultExpectation.params)
		}
	}

	return mmRemoveRefund
}

// ExpectOrderIDParam1 sets up expected param orderID for RefundsRepository.RemoveRefund
func (mmRemoveRefund *mRefundsRepositoryMockRemoveRefund) ExpectOrderIDParam1(orderID uint64) *mRefundsRepositoryMockRemoveRefund {
	if mmRemoveRefund.mock.funcRemoveRefund != nil {
		mmRemoveRefund.mock.t.Fatalf("RefundsRepositoryMock.RemoveRefund mock is already set by Set")
	}

	if mmRemoveRefund.defaultExpectation == nil {
		mmRemoveRefund.defaultExpectation = &RefundsRepositoryMockRemoveRefundExpectation{}
	}

	if mmRemoveRefund.defaultExpectation.params != nil {
		mmRemoveRefund.mock.t.Fatalf("RefundsRepositoryMock.RemoveRefund mock is already set by Expect")
	}

	if mmRemoveRefund.defaultExpectation.paramPtrs == nil {
		mmRemoveRefund.defaultExpectation.paramPtrs = &RefundsRepositoryMockRemoveRefundParamPtrs{}
	}
	mmRemoveRefund.defaultExpectation.paramPtrs.orderID = &orderID
	mmRemoveRefund.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmRemoveRefund
}

// Inspect accepts an inspector function that has same arguments as the RefundsRepository.RemoveRefund
func (mmRemoveRefund *mRefundsRepositoryMockRemoveRefund) Inspect(f func(orderID uint64)) *mRefundsRepositoryMockRemoveRefund {
	if mmRemoveRefund.mock.inspectFuncRemoveRefund != nil {
		mmRemoveRefund.mock.t.Fatalf("Inspect function is already set for RefundsRepositoryMock.RemoveRefund")
	}

	mmRemoveRefund.mock.inspectFuncRemoveRefund = f

	return mmRemoveRefund
}

// Return sets up results that will be returned by RefundsRepository.RemoveRefund
func (mmRemoveRefund *mRefundsRepositoryMockRemoveRefund) Return(err error) *RefundsRepositoryMock {
	if mmRemoveRefund.mock.funcRemoveRefund != nil {
		mmRemoveRefund.mock.t.Fatalf("RefundsRepositoryMock.RemoveRefund mock is already set by Set")
	}

	if mmRemoveRefund.defaultExpectation == nil {
		mmRemoveRefund.defaultExpectation = &RefundsRepositoryMockRemoveRefundExpectation{mock: mmRemoveRefund.mock}
	}
	mmRemoveRefund.defaultExpectation.results = &RefundsRepositoryMockRemoveRefundResults{err}
	mmRemoveRefund.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRemoveRefund.mock
}

// Set uses given function f to mock the RefundsRepository.RemoveRefund method
func (mmRemoveRefund *mRefundsRepositoryMockRemoveRefund) Set(f func(orderID uint64) (err error)) *RefundsRepositoryMock {
	if mmRemoveRefund.defaultExpectation != nil {
		mmRemoveRefund.mock.t.Fatalf("Default expectation is already set for the RefundsRepository.RemoveRefund method")
	}

	if len(mmRemoveRefund.expectations) > 0 {
		mmRemoveRefund.mock.t.Fatalf("Some expectations are already set for the RefundsRepository.RemoveRefund method")
	}

	mmRemoveRefund.mock.funcRemoveRefund = f
	mmRemoveRefund.mock.funcRemoveRefundOrigin = minimock.CallerInfo(1)
	return mmRemoveRefund.mock
}

// When sets expectation for the RefundsRepository.RemoveRefund which will trigger the result defined by the following
// Then helper
func (mmRemoveRefund *mRefundsRepositoryMockRemoveRefund) When(orderID uint64) *RefundsRepositoryMockRemoveRefundExpectation {
	if mmRemoveRefund.mock.funcRemoveRefund != nil {
		mmRemoveRefund.mock.t.Fatalf("RefundsRepositoryMock.RemoveRefund mock is already set by Set")
	}

	expectation := &RefundsRepositoryMockRemoveRefundExpectation{
		mock:               mmRemoveRefund.mock,
		params:             &RefundsRepositoryMockRemoveRefundParams{orderID},
		expectationOrigins: RefundsRepositoryMockRemoveRefundExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRemoveRefund.expectations = append(mmRemoveRefund.expectations, expectation)
	return expectation
}

// Then sets up RefundsRepository.RemoveRefund return parameters for the expectation previously defined by the When method
func (e *RefundsRepositoryMockRemoveRefundExpectation) Then(err error) *RefundsRepositoryMock {
	e.results = &RefundsRepositoryMockRemoveRefundResults{err}
	return e.mock
}

// Times sets number of times RefundsRepository.RemoveRefund should be invoked
func (mmRemoveRefund *mRefundsRepositoryMockRemoveRefund) Times(n uint64) *mRefundsRepositoryMockRemoveRefund {
	if n == 0 {
		mmRemoveRefund.mock.t.Fatalf("Times of RefundsRepositoryMock.RemoveRefund mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemoveRefund.expectedInvocations, n)
	mmRemoveRefund.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRemoveRefund
}

func (mmRemoveRefund *mRefundsRepositoryMockRemoveRefund) invocationsDone() bool {
	if len(mmRemoveRefund.expectations) == 0 && mmRemoveRefund.defaultExpectation == nil && mmRemoveRefund.mock.funcRemoveRefund == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemoveRefund.mock.afterRemoveRefundCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemoveRefund.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RemoveRefund implements mm_storage.RefundsRepository
func (mmRemoveRefund *RefundsRepositoryMock) RemoveRefund(orderID uint64) (err error) {
	mm_atomic.AddUint64(&mmRemoveRefund.beforeRemoveRefundCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveRefund.afterRemoveRefundCounter, 1)

	mmRemoveRefund.t.Helper()

	if mmRemoveRefund.inspectFuncRemoveRefund != nil {
		mmRemoveRefund.inspectFuncRemoveRefund(orderID)
	}

	mm_params := RefundsRepositoryMockRemoveRefundParams{orderID}

	// Record call args
	mmRemoveRefund.RemoveRefundMock.mutex.Lock()
	mmRemoveRefund.RemoveRefundMock.callArgs = append(mmRemoveRefund.RemoveRefundMock.callArgs, &mm_params)
	mmRemoveRefund.RemoveRefundMock.mutex.Unlock()

	for _, e := range mmRemoveRefund.RemoveRefundMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRemoveRefund.RemoveRefundMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveRefund.RemoveRefundMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveRefund.RemoveRefundMock.defaultExpectation.params
		mm_want_ptrs := mmRemoveRefund.RemoveRefundMock.defaultExpectation.paramPtrs

		mm_got := RefundsRepositoryMockRemoveRefundParams{orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmRemoveRefund.t.Errorf("RefundsRepositoryMock.RemoveRefund got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveRefund.RemoveRefundMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveRefund.t.Errorf("RefundsRepositoryMock.RemoveRefund got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRemoveRefund.RemoveRefundMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveRefund.RemoveRefundMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveRefund.t.Fatal("No results are set for the RefundsRepositoryMock.RemoveRefund")
		}
		return (*mm_results).err
	}
	if mmRemoveRefund.funcRemoveRefund != nil {
		return mmRemoveRefund.funcRemoveRefund(orderID)
	}
	mmRemoveRefund.t.Fatalf("Unexpected call to RefundsRepositoryMock.RemoveRefund. %v", orderID)
	return
}

// RemoveRefundAfterCounter returns a count of finished RefundsRepositoryMock.RemoveRefund invocations
func (mmRemoveRefund *RefundsRepositoryMock) RemoveRefundAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveRefund.afterRemoveRefundCounter)
}

// RemoveRefundBeforeCounter returns a count of RefundsRepositoryMock.RemoveRefund invocations
func (mmRemoveRefund *RefundsRepositoryMock) RemoveRefundBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveRefund.beforeRemoveRefundCounter)
}

// Calls returns a list of arguments used in each call to RefundsRepositoryMock.RemoveRefund.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveRefund *mRefundsRepositoryMockRemoveRefund) Calls() []*RefundsRepositoryMockRemoveRefundParams {
	mmRemoveRefund.mutex.RLock()

	argCopy := make([]*RefundsRepositoryMockRemoveRefundParams, len(mmRemoveRefund.callArgs))
	copy(argCopy, mmRemoveRefund.callArgs)

	mmRemoveRefund.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveRefundDone returns true if the count of the RemoveRefund invocations corresponds
// the number of defined expectations
func (m *RefundsRepositoryMock) MinimockRemoveRefundDone() bool {
	if m.RemoveRefundMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemoveRefundMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemoveRefundMock.invocationsDone()
}

// MinimockRemoveRefundInspect logs each unmet expectation
func (m *RefundsRepositoryMock) MinimockRemoveRefundInspect() {
	for _, e := range m.RemoveRefundMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RefundsRepositoryMock.RemoveRefund at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRemoveRefundCounter := mm_atomic.LoadUint64(&m.afterRemoveRefundCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveRefundMock.defaultExpectation != nil && afterRemoveRefundCounter < 1 {
		if m.RemoveRefundMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RefundsRepositoryMock.RemoveRefund at\n%s", m.RemoveRefundMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RefundsRepositoryMock.RemoveRefund at\n%s with params: %#v", m.RemoveRefundMock.defaultExpectation.expectationOrigins.origin, *m.RemoveRefundMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveRefund != nil && afterRemoveRefundCounter < 1 {
		m.t.Errorf("Expected call to RefundsRepositoryMock.RemoveRefund at\n%s", m.funcRemoveRefundOrigin)
	}

	if !m.RemoveRefundMock.invocationsDone() && afterRemoveRefundCounter > 0 {
		m.t.Errorf("Expected %d calls to RefundsRepositoryMock.RemoveRefund at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RemoveRefundMock.expectedInvocations), m.RemoveRefundMock.expectedInvocationsOrigin, afterRemoveRefundCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RefundsRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddRefundInspect()

			m.MinimockGetRefundsInspect()

			m.MinimockRemoveRefundInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RefundsRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RefundsRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddRefundDone() &&
		m.MinimockGetRefundsDone() &&
		m.MinimockRemoveRefundDone()
}
