// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mock

//go:generate minimock -i gitlab.ozon.dev/chppppr/homework/internal/storage.OrdersHistoryRepository -o orders_history.go -n OrdersHistoryRepositoryMock -p mock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.ozon.dev/chppppr/homework/internal/domain"
)

// OrdersHistoryRepositoryMock implements mm_storage.OrdersHistoryRepository
type OrdersHistoryRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddOrderStatus          func(orderID uint64, userID uint64, status string, order *domain.Order) (err error)
	funcAddOrderStatusOrigin    string
	inspectFuncAddOrderStatus   func(orderID uint64, userID uint64, status string, order *domain.Order)
	afterAddOrderStatusCounter  uint64
	beforeAddOrderStatusCounter uint64
	AddOrderStatusMock          mOrdersHistoryRepositoryMockAddOrderStatus

	funcGetOrderStatus          func(orderID uint64) (op1 *domain.OrderStatus, err error)
	funcGetOrderStatusOrigin    string
	inspectFuncGetOrderStatus   func(orderID uint64)
	afterGetOrderStatusCounter  uint64
	beforeGetOrderStatusCounter uint64
	GetOrderStatusMock          mOrdersHistoryRepositoryMockGetOrderStatus

	funcSetOrderStatus          func(orderID uint64, status string) (err error)
	funcSetOrderStatusOrigin    string
	inspectFuncSetOrderStatus   func(orderID uint64, status string)
	afterSetOrderStatusCounter  uint64
	beforeSetOrderStatusCounter uint64
	SetOrderStatusMock          mOrdersHistoryRepositoryMockSetOrderStatus
}

// NewOrdersHistoryRepositoryMock returns a mock for mm_storage.OrdersHistoryRepository
func NewOrdersHistoryRepositoryMock(t minimock.Tester) *OrdersHistoryRepositoryMock {
	m := &OrdersHistoryRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddOrderStatusMock = mOrdersHistoryRepositoryMockAddOrderStatus{mock: m}
	m.AddOrderStatusMock.callArgs = []*OrdersHistoryRepositoryMockAddOrderStatusParams{}

	m.GetOrderStatusMock = mOrdersHistoryRepositoryMockGetOrderStatus{mock: m}
	m.GetOrderStatusMock.callArgs = []*OrdersHistoryRepositoryMockGetOrderStatusParams{}

	m.SetOrderStatusMock = mOrdersHistoryRepositoryMockSetOrderStatus{mock: m}
	m.SetOrderStatusMock.callArgs = []*OrdersHistoryRepositoryMockSetOrderStatusParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mOrdersHistoryRepositoryMockAddOrderStatus struct {
	optional           bool
	mock               *OrdersHistoryRepositoryMock
	defaultExpectation *OrdersHistoryRepositoryMockAddOrderStatusExpectation
	expectations       []*OrdersHistoryRepositoryMockAddOrderStatusExpectation

	callArgs []*OrdersHistoryRepositoryMockAddOrderStatusParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrdersHistoryRepositoryMockAddOrderStatusExpectation specifies expectation struct of the OrdersHistoryRepository.AddOrderStatus
type OrdersHistoryRepositoryMockAddOrderStatusExpectation struct {
	mock               *OrdersHistoryRepositoryMock
	params             *OrdersHistoryRepositoryMockAddOrderStatusParams
	paramPtrs          *OrdersHistoryRepositoryMockAddOrderStatusParamPtrs
	expectationOrigins OrdersHistoryRepositoryMockAddOrderStatusExpectationOrigins
	results            *OrdersHistoryRepositoryMockAddOrderStatusResults
	returnOrigin       string
	Counter            uint64
}

// OrdersHistoryRepositoryMockAddOrderStatusParams contains parameters of the OrdersHistoryRepository.AddOrderStatus
type OrdersHistoryRepositoryMockAddOrderStatusParams struct {
	orderID uint64
	userID  uint64
	status  string
	order   *domain.Order
}

// OrdersHistoryRepositoryMockAddOrderStatusParamPtrs contains pointers to parameters of the OrdersHistoryRepository.AddOrderStatus
type OrdersHistoryRepositoryMockAddOrderStatusParamPtrs struct {
	orderID *uint64
	userID  *uint64
	status  *string
	order   **domain.Order
}

// OrdersHistoryRepositoryMockAddOrderStatusResults contains results of the OrdersHistoryRepository.AddOrderStatus
type OrdersHistoryRepositoryMockAddOrderStatusResults struct {
	err error
}

// OrdersHistoryRepositoryMockAddOrderStatusOrigins contains origins of expectations of the OrdersHistoryRepository.AddOrderStatus
type OrdersHistoryRepositoryMockAddOrderStatusExpectationOrigins struct {
	origin        string
	originOrderID string
	originUserID  string
	originStatus  string
	originOrder   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddOrderStatus *mOrdersHistoryRepositoryMockAddOrderStatus) Optional() *mOrdersHistoryRepositoryMockAddOrderStatus {
	mmAddOrderStatus.optional = true
	return mmAddOrderStatus
}

// Expect sets up expected params for OrdersHistoryRepository.AddOrderStatus
func (mmAddOrderStatus *mOrdersHistoryRepositoryMockAddOrderStatus) Expect(orderID uint64, userID uint64, status string, order *domain.Order) *mOrdersHistoryRepositoryMockAddOrderStatus {
	if mmAddOrderStatus.mock.funcAddOrderStatus != nil {
		mmAddOrderStatus.mock.t.Fatalf("OrdersHistoryRepositoryMock.AddOrderStatus mock is already set by Set")
	}

	if mmAddOrderStatus.defaultExpectation == nil {
		mmAddOrderStatus.defaultExpectation = &OrdersHistoryRepositoryMockAddOrderStatusExpectation{}
	}

	if mmAddOrderStatus.defaultExpectation.paramPtrs != nil {
		mmAddOrderStatus.mock.t.Fatalf("OrdersHistoryRepositoryMock.AddOrderStatus mock is already set by ExpectParams functions")
	}

	mmAddOrderStatus.defaultExpectation.params = &OrdersHistoryRepositoryMockAddOrderStatusParams{orderID, userID, status, order}
	mmAddOrderStatus.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddOrderStatus.expectations {
		if minimock.Equal(e.params, mmAddOrderStatus.defaultExpectation.params) {
			mmAddOrderStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddOrderStatus.defaultExpectation.params)
		}
	}

	return mmAddOrderStatus
}

// ExpectOrderIDParam1 sets up expected param orderID for OrdersHistoryRepository.AddOrderStatus
func (mmAddOrderStatus *mOrdersHistoryRepositoryMockAddOrderStatus) ExpectOrderIDParam1(orderID uint64) *mOrdersHistoryRepositoryMockAddOrderStatus {
	if mmAddOrderStatus.mock.funcAddOrderStatus != nil {
		mmAddOrderStatus.mock.t.Fatalf("OrdersHistoryRepositoryMock.AddOrderStatus mock is already set by Set")
	}

	if mmAddOrderStatus.defaultExpectation == nil {
		mmAddOrderStatus.defaultExpectation = &OrdersHistoryRepositoryMockAddOrderStatusExpectation{}
	}

	if mmAddOrderStatus.defaultExpectation.params != nil {
		mmAddOrderStatus.mock.t.Fatalf("OrdersHistoryRepositoryMock.AddOrderStatus mock is already set by Expect")
	}

	if mmAddOrderStatus.defaultExpectation.paramPtrs == nil {
		mmAddOrderStatus.defaultExpectation.paramPtrs = &OrdersHistoryRepositoryMockAddOrderStatusParamPtrs{}
	}
	mmAddOrderStatus.defaultExpectation.paramPtrs.orderID = &orderID
	mmAddOrderStatus.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmAddOrderStatus
}

// ExpectUserIDParam2 sets up expected param userID for OrdersHistoryRepository.AddOrderStatus
func (mmAddOrderStatus *mOrdersHistoryRepositoryMockAddOrderStatus) ExpectUserIDParam2(userID uint64) *mOrdersHistoryRepositoryMockAddOrderStatus {
	if mmAddOrderStatus.mock.funcAddOrderStatus != nil {
		mmAddOrderStatus.mock.t.Fatalf("OrdersHistoryRepositoryMock.AddOrderStatus mock is already set by Set")
	}

	if mmAddOrderStatus.defaultExpectation == nil {
		mmAddOrderStatus.defaultExpectation = &OrdersHistoryRepositoryMockAddOrderStatusExpectation{}
	}

	if mmAddOrderStatus.defaultExpectation.params != nil {
		mmAddOrderStatus.mock.t.Fatalf("OrdersHistoryRepositoryMock.AddOrderStatus mock is already set by Expect")
	}

	if mmAddOrderStatus.defaultExpectation.paramPtrs == nil {
		mmAddOrderStatus.defaultExpectation.paramPtrs = &OrdersHistoryRepositoryMockAddOrderStatusParamPtrs{}
	}
	mmAddOrderStatus.defaultExpectation.paramPtrs.userID = &userID
	mmAddOrderStatus.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmAddOrderStatus
}

// ExpectStatusParam3 sets up expected param status for OrdersHistoryRepository.AddOrderStatus
func (mmAddOrderStatus *mOrdersHistoryRepositoryMockAddOrderStatus) ExpectStatusParam3(status string) *mOrdersHistoryRepositoryMockAddOrderStatus {
	if mmAddOrderStatus.mock.funcAddOrderStatus != nil {
		mmAddOrderStatus.mock.t.Fatalf("OrdersHistoryRepositoryMock.AddOrderStatus mock is already set by Set")
	}

	if mmAddOrderStatus.defaultExpectation == nil {
		mmAddOrderStatus.defaultExpectation = &OrdersHistoryRepositoryMockAddOrderStatusExpectation{}
	}

	if mmAddOrderStatus.defaultExpectation.params != nil {
		mmAddOrderStatus.mock.t.Fatalf("OrdersHistoryRepositoryMock.AddOrderStatus mock is already set by Expect")
	}

	if mmAddOrderStatus.defaultExpectation.paramPtrs == nil {
		mmAddOrderStatus.defaultExpectation.paramPtrs = &OrdersHistoryRepositoryMockAddOrderStatusParamPtrs{}
	}
	mmAddOrderStatus.defaultExpectation.paramPtrs.status = &status
	mmAddOrderStatus.defaultExpectation.expectationOrigins.originStatus = minimock.CallerInfo(1)

	return mmAddOrderStatus
}

// ExpectOrderParam4 sets up expected param order for OrdersHistoryRepository.AddOrderStatus
func (mmAddOrderStatus *mOrdersHistoryRepositoryMockAddOrderStatus) ExpectOrderParam4(order *domain.Order) *mOrdersHistoryRepositoryMockAddOrderStatus {
	if mmAddOrderStatus.mock.funcAddOrderStatus != nil {
		mmAddOrderStatus.mock.t.Fatalf("OrdersHistoryRepositoryMock.AddOrderStatus mock is already set by Set")
	}

	if mmAddOrderStatus.defaultExpectation == nil {
		mmAddOrderStatus.defaultExpectation = &OrdersHistoryRepositoryMockAddOrderStatusExpectation{}
	}

	if mmAddOrderStatus.defaultExpectation.params != nil {
		mmAddOrderStatus.mock.t.Fatalf("OrdersHistoryRepositoryMock.AddOrderStatus mock is already set by Expect")
	}

	if mmAddOrderStatus.defaultExpectation.paramPtrs == nil {
		mmAddOrderStatus.defaultExpectation.paramPtrs = &OrdersHistoryRepositoryMockAddOrderStatusParamPtrs{}
	}
	mmAddOrderStatus.defaultExpectation.paramPtrs.order = &order
	mmAddOrderStatus.defaultExpectation.expectationOrigins.originOrder = minimock.CallerInfo(1)

	return mmAddOrderStatus
}

// Inspect accepts an inspector function that has same arguments as the OrdersHistoryRepository.AddOrderStatus
func (mmAddOrderStatus *mOrdersHistoryRepositoryMockAddOrderStatus) Inspect(f func(orderID uint64, userID uint64, status string, order *domain.Order)) *mOrdersHistoryRepositoryMockAddOrderStatus {
	if mmAddOrderStatus.mock.inspectFuncAddOrderStatus != nil {
		mmAddOrderStatus.mock.t.Fatalf("Inspect function is already set for OrdersHistoryRepositoryMock.AddOrderStatus")
	}

	mmAddOrderStatus.mock.inspectFuncAddOrderStatus = f

	return mmAddOrderStatus
}

// Return sets up results that will be returned by OrdersHistoryRepository.AddOrderStatus
func (mmAddOrderStatus *mOrdersHistoryRepositoryMockAddOrderStatus) Return(err error) *OrdersHistoryRepositoryMock {
	if mmAddOrderStatus.mock.funcAddOrderStatus != nil {
		mmAddOrderStatus.mock.t.Fatalf("OrdersHistoryRepositoryMock.AddOrderStatus mock is already set by Set")
	}

	if mmAddOrderStatus.defaultExpectation == nil {
		mmAddOrderStatus.defaultExpectation = &OrdersHistoryRepositoryMockAddOrderStatusExpectation{mock: mmAddOrderStatus.mock}
	}
	mmAddOrderStatus.defaultExpectation.results = &OrdersHistoryRepositoryMockAddOrderStatusResults{err}
	mmAddOrderStatus.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddOrderStatus.mock
}

// Set uses given function f to mock the OrdersHistoryRepository.AddOrderStatus method
func (mmAddOrderStatus *mOrdersHistoryRepositoryMockAddOrderStatus) Set(f func(orderID uint64, userID uint64, status string, order *domain.Order) (err error)) *OrdersHistoryRepositoryMock {
	if mmAddOrderStatus.defaultExpectation != nil {
		mmAddOrderStatus.mock.t.Fatalf("Default expectation is already set for the OrdersHistoryRepository.AddOrderStatus method")
	}

	if len(mmAddOrderStatus.expectations) > 0 {
		mmAddOrderStatus.mock.t.Fatalf("Some expectations are already set for the OrdersHistoryRepository.AddOrderStatus method")
	}

	mmAddOrderStatus.mock.funcAddOrderStatus = f
	mmAddOrderStatus.mock.funcAddOrderStatusOrigin = minimock.CallerInfo(1)
	return mmAddOrderStatus.mock
}

// When sets expectation for the OrdersHistoryRepository.AddOrderStatus which will trigger the result defined by the following
// Then helper
func (mmAddOrderStatus *mOrdersHistoryRepositoryMockAddOrderStatus) When(orderID uint64, userID uint64, status string, order *domain.Order) *OrdersHistoryRepositoryMockAddOrderStatusExpectation {
	if mmAddOrderStatus.mock.funcAddOrderStatus != nil {
		mmAddOrderStatus.mock.t.Fatalf("OrdersHistoryRepositoryMock.AddOrderStatus mock is already set by Set")
	}

	expectation := &OrdersHistoryRepositoryMockAddOrderStatusExpectation{
		mock:               mmAddOrderStatus.mock,
		params:             &OrdersHistoryRepositoryMockAddOrderStatusParams{orderID, userID, status, order},
		expectationOrigins: OrdersHistoryRepositoryMockAddOrderStatusExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddOrderStatus.expectations = append(mmAddOrderStatus.expectations, expectation)
	return expectation
}

// Then sets up OrdersHistoryRepository.AddOrderStatus return parameters for the expectation previously defined by the When method
func (e *OrdersHistoryRepositoryMockAddOrderStatusExpectation) Then(err error) *OrdersHistoryRepositoryMock {
	e.results = &OrdersHistoryRepositoryMockAddOrderStatusResults{err}
	return e.mock
}

// Times sets number of times OrdersHistoryRepository.AddOrderStatus should be invoked
func (mmAddOrderStatus *mOrdersHistoryRepositoryMockAddOrderStatus) Times(n uint64) *mOrdersHistoryRepositoryMockAddOrderStatus {
	if n == 0 {
		mmAddOrderStatus.mock.t.Fatalf("Times of OrdersHistoryRepositoryMock.AddOrderStatus mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddOrderStatus.expectedInvocations, n)
	mmAddOrderStatus.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddOrderStatus
}

func (mmAddOrderStatus *mOrdersHistoryRepositoryMockAddOrderStatus) invocationsDone() bool {
	if len(mmAddOrderStatus.expectations) == 0 && mmAddOrderStatus.defaultExpectation == nil && mmAddOrderStatus.mock.funcAddOrderStatus == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddOrderStatus.mock.afterAddOrderStatusCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddOrderStatus.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddOrderStatus implements mm_storage.OrdersHistoryRepository
func (mmAddOrderStatus *OrdersHistoryRepositoryMock) AddOrderStatus(orderID uint64, userID uint64, status string, order *domain.Order) (err error) {
	mm_atomic.AddUint64(&mmAddOrderStatus.beforeAddOrderStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmAddOrderStatus.afterAddOrderStatusCounter, 1)

	mmAddOrderStatus.t.Helper()

	if mmAddOrderStatus.inspectFuncAddOrderStatus != nil {
		mmAddOrderStatus.inspectFuncAddOrderStatus(orderID, userID, status, order)
	}

	mm_params := OrdersHistoryRepositoryMockAddOrderStatusParams{orderID, userID, status, order}

	// Record call args
	mmAddOrderStatus.AddOrderStatusMock.mutex.Lock()
	mmAddOrderStatus.AddOrderStatusMock.callArgs = append(mmAddOrderStatus.AddOrderStatusMock.callArgs, &mm_params)
	mmAddOrderStatus.AddOrderStatusMock.mutex.Unlock()

	for _, e := range mmAddOrderStatus.AddOrderStatusMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddOrderStatus.AddOrderStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddOrderStatus.AddOrderStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmAddOrderStatus.AddOrderStatusMock.defaultExpectation.params
		mm_want_ptrs := mmAddOrderStatus.AddOrderStatusMock.defaultExpectation.paramPtrs

		mm_got := OrdersHistoryRepositoryMockAddOrderStatusParams{orderID, userID, status, order}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmAddOrderStatus.t.Errorf("OrdersHistoryRepositoryMock.AddOrderStatus got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddOrderStatus.AddOrderStatusMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmAddOrderStatus.t.Errorf("OrdersHistoryRepositoryMock.AddOrderStatus got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddOrderStatus.AddOrderStatusMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.status != nil && !minimock.Equal(*mm_want_ptrs.status, mm_got.status) {
				mmAddOrderStatus.t.Errorf("OrdersHistoryRepositoryMock.AddOrderStatus got unexpected parameter status, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddOrderStatus.AddOrderStatusMock.defaultExpectation.expectationOrigins.originStatus, *mm_want_ptrs.status, mm_got.status, minimock.Diff(*mm_want_ptrs.status, mm_got.status))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmAddOrderStatus.t.Errorf("OrdersHistoryRepositoryMock.AddOrderStatus got unexpected parameter order, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddOrderStatus.AddOrderStatusMock.defaultExpectation.expectationOrigins.originOrder, *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddOrderStatus.t.Errorf("OrdersHistoryRepositoryMock.AddOrderStatus got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddOrderStatus.AddOrderStatusMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddOrderStatus.AddOrderStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmAddOrderStatus.t.Fatal("No results are set for the OrdersHistoryRepositoryMock.AddOrderStatus")
		}
		return (*mm_results).err
	}
	if mmAddOrderStatus.funcAddOrderStatus != nil {
		return mmAddOrderStatus.funcAddOrderStatus(orderID, userID, status, order)
	}
	mmAddOrderStatus.t.Fatalf("Unexpected call to OrdersHistoryRepositoryMock.AddOrderStatus. %v %v %v %v", orderID, userID, status, order)
	return
}

// AddOrderStatusAfterCounter returns a count of finished OrdersHistoryRepositoryMock.AddOrderStatus invocations
func (mmAddOrderStatus *OrdersHistoryRepositoryMock) AddOrderStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddOrderStatus.afterAddOrderStatusCounter)
}

// AddOrderStatusBeforeCounter returns a count of OrdersHistoryRepositoryMock.AddOrderStatus invocations
func (mmAddOrderStatus *OrdersHistoryRepositoryMock) AddOrderStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddOrderStatus.beforeAddOrderStatusCounter)
}

// Calls returns a list of arguments used in each call to OrdersHistoryRepositoryMock.AddOrderStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddOrderStatus *mOrdersHistoryRepositoryMockAddOrderStatus) Calls() []*OrdersHistoryRepositoryMockAddOrderStatusParams {
	mmAddOrderStatus.mutex.RLock()

	argCopy := make([]*OrdersHistoryRepositoryMockAddOrderStatusParams, len(mmAddOrderStatus.callArgs))
	copy(argCopy, mmAddOrderStatus.callArgs)

	mmAddOrderStatus.mutex.RUnlock()

	return argCopy
}

// MinimockAddOrderStatusDone returns true if the count of the AddOrderStatus invocations corresponds
// the number of defined expectations
func (m *OrdersHistoryRepositoryMock) MinimockAddOrderStatusDone() bool {
	if m.AddOrderStatusMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddOrderStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddOrderStatusMock.invocationsDone()
}

// MinimockAddOrderStatusInspect logs each unmet expectation
func (m *OrdersHistoryRepositoryMock) MinimockAddOrderStatusInspect() {
	for _, e := range m.AddOrderStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrdersHistoryRepositoryMock.AddOrderStatus at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddOrderStatusCounter := mm_atomic.LoadUint64(&m.afterAddOrderStatusCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddOrderStatusMock.defaultExpectation != nil && afterAddOrderStatusCounter < 1 {
		if m.AddOrderStatusMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrdersHistoryRepositoryMock.AddOrderStatus at\n%s", m.AddOrderStatusMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrdersHistoryRepositoryMock.AddOrderStatus at\n%s with params: %#v", m.AddOrderStatusMock.defaultExpectation.expectationOrigins.origin, *m.AddOrderStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddOrderStatus != nil && afterAddOrderStatusCounter < 1 {
		m.t.Errorf("Expected call to OrdersHistoryRepositoryMock.AddOrderStatus at\n%s", m.funcAddOrderStatusOrigin)
	}

	if !m.AddOrderStatusMock.invocationsDone() && afterAddOrderStatusCounter > 0 {
		m.t.Errorf("Expected %d calls to OrdersHistoryRepositoryMock.AddOrderStatus at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddOrderStatusMock.expectedInvocations), m.AddOrderStatusMock.expectedInvocationsOrigin, afterAddOrderStatusCounter)
	}
}

type mOrdersHistoryRepositoryMockGetOrderStatus struct {
	optional           bool
	mock               *OrdersHistoryRepositoryMock
	defaultExpectation *OrdersHistoryRepositoryMockGetOrderStatusExpectation
	expectations       []*OrdersHistoryRepositoryMockGetOrderStatusExpectation

	callArgs []*OrdersHistoryRepositoryMockGetOrderStatusParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrdersHistoryRepositoryMockGetOrderStatusExpectation specifies expectation struct of the OrdersHistoryRepository.GetOrderStatus
type OrdersHistoryRepositoryMockGetOrderStatusExpectation struct {
	mock               *OrdersHistoryRepositoryMock
	params             *OrdersHistoryRepositoryMockGetOrderStatusParams
	paramPtrs          *OrdersHistoryRepositoryMockGetOrderStatusParamPtrs
	expectationOrigins OrdersHistoryRepositoryMockGetOrderStatusExpectationOrigins
	results            *OrdersHistoryRepositoryMockGetOrderStatusResults
	returnOrigin       string
	Counter            uint64
}

// OrdersHistoryRepositoryMockGetOrderStatusParams contains parameters of the OrdersHistoryRepository.GetOrderStatus
type OrdersHistoryRepositoryMockGetOrderStatusParams struct {
	orderID uint64
}

// OrdersHistoryRepositoryMockGetOrderStatusParamPtrs contains pointers to parameters of the OrdersHistoryRepository.GetOrderStatus
type OrdersHistoryRepositoryMockGetOrderStatusParamPtrs struct {
	orderID *uint64
}

// OrdersHistoryRepositoryMockGetOrderStatusResults contains results of the OrdersHistoryRepository.GetOrderStatus
type OrdersHistoryRepositoryMockGetOrderStatusResults struct {
	op1 *domain.OrderStatus
	err error
}

// OrdersHistoryRepositoryMockGetOrderStatusOrigins contains origins of expectations of the OrdersHistoryRepository.GetOrderStatus
type OrdersHistoryRepositoryMockGetOrderStatusExpectationOrigins struct {
	origin        string
	originOrderID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrderStatus *mOrdersHistoryRepositoryMockGetOrderStatus) Optional() *mOrdersHistoryRepositoryMockGetOrderStatus {
	mmGetOrderStatus.optional = true
	return mmGetOrderStatus
}

// Expect sets up expected params for OrdersHistoryRepository.GetOrderStatus
func (mmGetOrderStatus *mOrdersHistoryRepositoryMockGetOrderStatus) Expect(orderID uint64) *mOrdersHistoryRepositoryMockGetOrderStatus {
	if mmGetOrderStatus.mock.funcGetOrderStatus != nil {
		mmGetOrderStatus.mock.t.Fatalf("OrdersHistoryRepositoryMock.GetOrderStatus mock is already set by Set")
	}

	if mmGetOrderStatus.defaultExpectation == nil {
		mmGetOrderStatus.defaultExpectation = &OrdersHistoryRepositoryMockGetOrderStatusExpectation{}
	}

	if mmGetOrderStatus.defaultExpectation.paramPtrs != nil {
		mmGetOrderStatus.mock.t.Fatalf("OrdersHistoryRepositoryMock.GetOrderStatus mock is already set by ExpectParams functions")
	}

	mmGetOrderStatus.defaultExpectation.params = &OrdersHistoryRepositoryMockGetOrderStatusParams{orderID}
	mmGetOrderStatus.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetOrderStatus.expectations {
		if minimock.Equal(e.params, mmGetOrderStatus.defaultExpectation.params) {
			mmGetOrderStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrderStatus.defaultExpectation.params)
		}
	}

	return mmGetOrderStatus
}

// ExpectOrderIDParam1 sets up expected param orderID for OrdersHistoryRepository.GetOrderStatus
func (mmGetOrderStatus *mOrdersHistoryRepositoryMockGetOrderStatus) ExpectOrderIDParam1(orderID uint64) *mOrdersHistoryRepositoryMockGetOrderStatus {
	if mmGetOrderStatus.mock.funcGetOrderStatus != nil {
		mmGetOrderStatus.mock.t.Fatalf("OrdersHistoryRepositoryMock.GetOrderStatus mock is already set by Set")
	}

	if mmGetOrderStatus.defaultExpectation == nil {
		mmGetOrderStatus.defaultExpectation = &OrdersHistoryRepositoryMockGetOrderStatusExpectation{}
	}

	if mmGetOrderStatus.defaultExpectation.params != nil {
		mmGetOrderStatus.mock.t.Fatalf("OrdersHistoryRepositoryMock.GetOrderStatus mock is already set by Expect")
	}

	if mmGetOrderStatus.defaultExpectation.paramPtrs == nil {
		mmGetOrderStatus.defaultExpectation.paramPtrs = &OrdersHistoryRepositoryMockGetOrderStatusParamPtrs{}
	}
	mmGetOrderStatus.defaultExpectation.paramPtrs.orderID = &orderID
	mmGetOrderStatus.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmGetOrderStatus
}

// Inspect accepts an inspector function that has same arguments as the OrdersHistoryRepository.GetOrderStatus
func (mmGetOrderStatus *mOrdersHistoryRepositoryMockGetOrderStatus) Inspect(f func(orderID uint64)) *mOrdersHistoryRepositoryMockGetOrderStatus {
	if mmGetOrderStatus.mock.inspectFuncGetOrderStatus != nil {
		mmGetOrderStatus.mock.t.Fatalf("Inspect function is already set for OrdersHistoryRepositoryMock.GetOrderStatus")
	}

	mmGetOrderStatus.mock.inspectFuncGetOrderStatus = f

	return mmGetOrderStatus
}

// Return sets up results that will be returned by OrdersHistoryRepository.GetOrderStatus
func (mmGetOrderStatus *mOrdersHistoryRepositoryMockGetOrderStatus) Return(op1 *domain.OrderStatus, err error) *OrdersHistoryRepositoryMock {
	if mmGetOrderStatus.mock.funcGetOrderStatus != nil {
		mmGetOrderStatus.mock.t.Fatalf("OrdersHistoryRepositoryMock.GetOrderStatus mock is already set by Set")
	}

	if mmGetOrderStatus.defaultExpectation == nil {
		mmGetOrderStatus.defaultExpectation = &OrdersHistoryRepositoryMockGetOrderStatusExpectation{mock: mmGetOrderStatus.mock}
	}
	mmGetOrderStatus.defaultExpectation.results = &OrdersHistoryRepositoryMockGetOrderStatusResults{op1, err}
	mmGetOrderStatus.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOrderStatus.mock
}

// Set uses given function f to mock the OrdersHistoryRepository.GetOrderStatus method
func (mmGetOrderStatus *mOrdersHistoryRepositoryMockGetOrderStatus) Set(f func(orderID uint64) (op1 *domain.OrderStatus, err error)) *OrdersHistoryRepositoryMock {
	if mmGetOrderStatus.defaultExpectation != nil {
		mmGetOrderStatus.mock.t.Fatalf("Default expectation is already set for the OrdersHistoryRepository.GetOrderStatus method")
	}

	if len(mmGetOrderStatus.expectations) > 0 {
		mmGetOrderStatus.mock.t.Fatalf("Some expectations are already set for the OrdersHistoryRepository.GetOrderStatus method")
	}

	mmGetOrderStatus.mock.funcGetOrderStatus = f
	mmGetOrderStatus.mock.funcGetOrderStatusOrigin = minimock.CallerInfo(1)
	return mmGetOrderStatus.mock
}

// When sets expectation for the OrdersHistoryRepository.GetOrderStatus which will trigger the result defined by the following
// Then helper
func (mmGetOrderStatus *mOrdersHistoryRepositoryMockGetOrderStatus) When(orderID uint64) *OrdersHistoryRepositoryMockGetOrderStatusExpectation {
	if mmGetOrderStatus.mock.funcGetOrderStatus != nil {
		mmGetOrderStatus.mock.t.Fatalf("OrdersHistoryRepositoryMock.GetOrderStatus mock is already set by Set")
	}

	expectation := &OrdersHistoryRepositoryMockGetOrderStatusExpectation{
		mock:               mmGetOrderStatus.mock,
		params:             &OrdersHistoryRepositoryMockGetOrderStatusParams{orderID},
		expectationOrigins: OrdersHistoryRepositoryMockGetOrderStatusExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetOrderStatus.expectations = append(mmGetOrderStatus.expectations, expectation)
	return expectation
}

// Then sets up OrdersHistoryRepository.GetOrderStatus return parameters for the expectation previously defined by the When method
func (e *OrdersHistoryRepositoryMockGetOrderStatusExpectation) Then(op1 *domain.OrderStatus, err error) *OrdersHistoryRepositoryMock {
	e.results = &OrdersHistoryRepositoryMockGetOrderStatusResults{op1, err}
	return e.mock
}

// Times sets number of times OrdersHistoryRepository.GetOrderStatus should be invoked
func (mmGetOrderStatus *mOrdersHistoryRepositoryMockGetOrderStatus) Times(n uint64) *mOrdersHistoryRepositoryMockGetOrderStatus {
	if n == 0 {
		mmGetOrderStatus.mock.t.Fatalf("Times of OrdersHistoryRepositoryMock.GetOrderStatus mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrderStatus.expectedInvocations, n)
	mmGetOrderStatus.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOrderStatus
}

func (mmGetOrderStatus *mOrdersHistoryRepositoryMockGetOrderStatus) invocationsDone() bool {
	if len(mmGetOrderStatus.expectations) == 0 && mmGetOrderStatus.defaultExpectation == nil && mmGetOrderStatus.mock.funcGetOrderStatus == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrderStatus.mock.afterGetOrderStatusCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrderStatus.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrderStatus implements mm_storage.OrdersHistoryRepository
func (mmGetOrderStatus *OrdersHistoryRepositoryMock) GetOrderStatus(orderID uint64) (op1 *domain.OrderStatus, err error) {
	mm_atomic.AddUint64(&mmGetOrderStatus.beforeGetOrderStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrderStatus.afterGetOrderStatusCounter, 1)

	mmGetOrderStatus.t.Helper()

	if mmGetOrderStatus.inspectFuncGetOrderStatus != nil {
		mmGetOrderStatus.inspectFuncGetOrderStatus(orderID)
	}

	mm_params := OrdersHistoryRepositoryMockGetOrderStatusParams{orderID}

	// Record call args
	mmGetOrderStatus.GetOrderStatusMock.mutex.Lock()
	mmGetOrderStatus.GetOrderStatusMock.callArgs = append(mmGetOrderStatus.GetOrderStatusMock.callArgs, &mm_params)
	mmGetOrderStatus.GetOrderStatusMock.mutex.Unlock()

	for _, e := range mmGetOrderStatus.GetOrderStatusMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetOrderStatus.GetOrderStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrderStatus.GetOrderStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrderStatus.GetOrderStatusMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrderStatus.GetOrderStatusMock.defaultExpectation.paramPtrs

		mm_got := OrdersHistoryRepositoryMockGetOrderStatusParams{orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmGetOrderStatus.t.Errorf("OrdersHistoryRepositoryMock.GetOrderStatus got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrderStatus.GetOrderStatusMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrderStatus.t.Errorf("OrdersHistoryRepositoryMock.GetOrderStatus got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetOrderStatus.GetOrderStatusMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrderStatus.GetOrderStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrderStatus.t.Fatal("No results are set for the OrdersHistoryRepositoryMock.GetOrderStatus")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetOrderStatus.funcGetOrderStatus != nil {
		return mmGetOrderStatus.funcGetOrderStatus(orderID)
	}
	mmGetOrderStatus.t.Fatalf("Unexpected call to OrdersHistoryRepositoryMock.GetOrderStatus. %v", orderID)
	return
}

// GetOrderStatusAfterCounter returns a count of finished OrdersHistoryRepositoryMock.GetOrderStatus invocations
func (mmGetOrderStatus *OrdersHistoryRepositoryMock) GetOrderStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrderStatus.afterGetOrderStatusCounter)
}

// GetOrderStatusBeforeCounter returns a count of OrdersHistoryRepositoryMock.GetOrderStatus invocations
func (mmGetOrderStatus *OrdersHistoryRepositoryMock) GetOrderStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrderStatus.beforeGetOrderStatusCounter)
}

// Calls returns a list of arguments used in each call to OrdersHistoryRepositoryMock.GetOrderStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrderStatus *mOrdersHistoryRepositoryMockGetOrderStatus) Calls() []*OrdersHistoryRepositoryMockGetOrderStatusParams {
	mmGetOrderStatus.mutex.RLock()

	argCopy := make([]*OrdersHistoryRepositoryMockGetOrderStatusParams, len(mmGetOrderStatus.callArgs))
	copy(argCopy, mmGetOrderStatus.callArgs)

	mmGetOrderStatus.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrderStatusDone returns true if the count of the GetOrderStatus invocations corresponds
// the number of defined expectations
func (m *OrdersHistoryRepositoryMock) MinimockGetOrderStatusDone() bool {
	if m.GetOrderStatusMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrderStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrderStatusMock.invocationsDone()
}

// MinimockGetOrderStatusInspect logs each unmet expectation
func (m *OrdersHistoryRepositoryMock) MinimockGetOrderStatusInspect() {
	for _, e := range m.GetOrderStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrdersHistoryRepositoryMock.GetOrderStatus at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetOrderStatusCounter := mm_atomic.LoadUint64(&m.afterGetOrderStatusCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderStatusMock.defaultExpectation != nil && afterGetOrderStatusCounter < 1 {
		if m.GetOrderStatusMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrdersHistoryRepositoryMock.GetOrderStatus at\n%s", m.GetOrderStatusMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrdersHistoryRepositoryMock.GetOrderStatus at\n%s with params: %#v", m.GetOrderStatusMock.defaultExpectation.expectationOrigins.origin, *m.GetOrderStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrderStatus != nil && afterGetOrderStatusCounter < 1 {
		m.t.Errorf("Expected call to OrdersHistoryRepositoryMock.GetOrderStatus at\n%s", m.funcGetOrderStatusOrigin)
	}

	if !m.GetOrderStatusMock.invocationsDone() && afterGetOrderStatusCounter > 0 {
		m.t.Errorf("Expected %d calls to OrdersHistoryRepositoryMock.GetOrderStatus at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrderStatusMock.expectedInvocations), m.GetOrderStatusMock.expectedInvocationsOrigin, afterGetOrderStatusCounter)
	}
}

type mOrdersHistoryRepositoryMockSetOrderStatus struct {
	optional           bool
	mock               *OrdersHistoryRepositoryMock
	defaultExpectation *OrdersHistoryRepositoryMockSetOrderStatusExpectation
	expectations       []*OrdersHistoryRepositoryMockSetOrderStatusExpectation

	callArgs []*OrdersHistoryRepositoryMockSetOrderStatusParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrdersHistoryRepositoryMockSetOrderStatusExpectation specifies expectation struct of the OrdersHistoryRepository.SetOrderStatus
type OrdersHistoryRepositoryMockSetOrderStatusExpectation struct {
	mock               *OrdersHistoryRepositoryMock
	params             *OrdersHistoryRepositoryMockSetOrderStatusParams
	paramPtrs          *OrdersHistoryRepositoryMockSetOrderStatusParamPtrs
	expectationOrigins OrdersHistoryRepositoryMockSetOrderStatusExpectationOrigins
	results            *OrdersHistoryRepositoryMockSetOrderStatusResults
	returnOrigin       string
	Counter            uint64
}

// OrdersHistoryRepositoryMockSetOrderStatusParams contains parameters of the OrdersHistoryRepository.SetOrderStatus
type OrdersHistoryRepositoryMockSetOrderStatusParams struct {
	orderID uint64
	status  string
}

// OrdersHistoryRepositoryMockSetOrderStatusParamPtrs contains pointers to parameters of the OrdersHistoryRepository.SetOrderStatus
type OrdersHistoryRepositoryMockSetOrderStatusParamPtrs struct {
	orderID *uint64
	status  *string
}

// OrdersHistoryRepositoryMockSetOrderStatusResults contains results of the OrdersHistoryRepository.SetOrderStatus
type OrdersHistoryRepositoryMockSetOrderStatusResults struct {
	err error
}

// OrdersHistoryRepositoryMockSetOrderStatusOrigins contains origins of expectations of the OrdersHistoryRepository.SetOrderStatus
type OrdersHistoryRepositoryMockSetOrderStatusExpectationOrigins struct {
	origin        string
	originOrderID string
	originStatus  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetOrderStatus *mOrdersHistoryRepositoryMockSetOrderStatus) Optional() *mOrdersHistoryRepositoryMockSetOrderStatus {
	mmSetOrderStatus.optional = true
	return mmSetOrderStatus
}

// Expect sets up expected params for OrdersHistoryRepository.SetOrderStatus
func (mmSetOrderStatus *mOrdersHistoryRepositoryMockSetOrderStatus) Expect(orderID uint64, status string) *mOrdersHistoryRepositoryMockSetOrderStatus {
	if mmSetOrderStatus.mock.funcSetOrderStatus != nil {
		mmSetOrderStatus.mock.t.Fatalf("OrdersHistoryRepositoryMock.SetOrderStatus mock is already set by Set")
	}

	if mmSetOrderStatus.defaultExpectation == nil {
		mmSetOrderStatus.defaultExpectation = &OrdersHistoryRepositoryMockSetOrderStatusExpectation{}
	}

	if mmSetOrderStatus.defaultExpectation.paramPtrs != nil {
		mmSetOrderStatus.mock.t.Fatalf("OrdersHistoryRepositoryMock.SetOrderStatus mock is already set by ExpectParams functions")
	}

	mmSetOrderStatus.defaultExpectation.params = &OrdersHistoryRepositoryMockSetOrderStatusParams{orderID, status}
	mmSetOrderStatus.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetOrderStatus.expectations {
		if minimock.Equal(e.params, mmSetOrderStatus.defaultExpectation.params) {
			mmSetOrderStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetOrderStatus.defaultExpectation.params)
		}
	}

	return mmSetOrderStatus
}

// ExpectOrderIDParam1 sets up expected param orderID for OrdersHistoryRepository.SetOrderStatus
func (mmSetOrderStatus *mOrdersHistoryRepositoryMockSetOrderStatus) ExpectOrderIDParam1(orderID uint64) *mOrdersHistoryRepositoryMockSetOrderStatus {
	if mmSetOrderStatus.mock.funcSetOrderStatus != nil {
		mmSetOrderStatus.mock.t.Fatalf("OrdersHistoryRepositoryMock.SetOrderStatus mock is already set by Set")
	}

	if mmSetOrderStatus.defaultExpectation == nil {
		mmSetOrderStatus.defaultExpectation = &OrdersHistoryRepositoryMockSetOrderStatusExpectation{}
	}

	if mmSetOrderStatus.defaultExpectation.params != nil {
		mmSetOrderStatus.mock.t.Fatalf("OrdersHistoryRepositoryMock.SetOrderStatus mock is already set by Expect")
	}

	if mmSetOrderStatus.defaultExpectation.paramPtrs == nil {
		mmSetOrderStatus.defaultExpectation.paramPtrs = &OrdersHistoryRepositoryMockSetOrderStatusParamPtrs{}
	}
	mmSetOrderStatus.defaultExpectation.paramPtrs.orderID = &orderID
	mmSetOrderStatus.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmSetOrderStatus
}

// ExpectStatusParam2 sets up expected param status for OrdersHistoryRepository.SetOrderStatus
func (mmSetOrderStatus *mOrdersHistoryRepositoryMockSetOrderStatus) ExpectStatusParam2(status string) *mOrdersHistoryRepositoryMockSetOrderStatus {
	if mmSetOrderStatus.mock.funcSetOrderStatus != nil {
		mmSetOrderStatus.mock.t.Fatalf("OrdersHistoryRepositoryMock.SetOrderStatus mock is already set by Set")
	}

	if mmSetOrderStatus.defaultExpectation == nil {
		mmSetOrderStatus.defaultExpectation = &OrdersHistoryRepositoryMockSetOrderStatusExpectation{}
	}

	if mmSetOrderStatus.defaultExpectation.params != nil {
		mmSetOrderStatus.mock.t.Fatalf("OrdersHistoryRepositoryMock.SetOrderStatus mock is already set by Expect")
	}

	if mmSetOrderStatus.defaultExpectation.paramPtrs == nil {
		mmSetOrderStatus.defaultExpectation.paramPtrs = &OrdersHistoryRepositoryMockSetOrderStatusParamPtrs{}
	}
	mmSetOrderStatus.defaultExpectation.paramPtrs.status = &status
	mmSetOrderStatus.defaultExpectation.expectationOrigins.originStatus = minimock.CallerInfo(1)

	return mmSetOrderStatus
}

// Inspect accepts an inspector function that has same arguments as the OrdersHistoryRepository.SetOrderStatus
func (mmSetOrderStatus *mOrdersHistoryRepositoryMockSetOrderStatus) Inspect(f func(orderID uint64, status string)) *mOrdersHistoryRepositoryMockSetOrderStatus {
	if mmSetOrderStatus.mock.inspectFuncSetOrderStatus != nil {
		mmSetOrderStatus.mock.t.Fatalf("Inspect function is already set for OrdersHistoryRepositoryMock.SetOrderStatus")
	}

	mmSetOrderStatus.mock.inspectFuncSetOrderStatus = f

	return mmSetOrderStatus
}

// Return sets up results that will be returned by OrdersHistoryRepository.SetOrderStatus
func (mmSetOrderStatus *mOrdersHistoryRepositoryMockSetOrderStatus) Return(err error) *OrdersHistoryRepositoryMock {
	if mmSetOrderStatus.mock.funcSetOrderStatus != nil {
		mmSetOrderStatus.mock.t.Fatalf("OrdersHistoryRepositoryMock.SetOrderStatus mock is already set by Set")
	}

	if mmSetOrderStatus.defaultExpectation == nil {
		mmSetOrderStatus.defaultExpectation = &OrdersHistoryRepositoryMockSetOrderStatusExpectation{mock: mmSetOrderStatus.mock}
	}
	mmSetOrderStatus.defaultExpectation.results = &OrdersHistoryRepositoryMockSetOrderStatusResults{err}
	mmSetOrderStatus.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetOrderStatus.mock
}

// Set uses given function f to mock the OrdersHistoryRepository.SetOrderStatus method
func (mmSetOrderStatus *mOrdersHistoryRepositoryMockSetOrderStatus) Set(f func(orderID uint64, status string) (err error)) *OrdersHistoryRepositoryMock {
	if mmSetOrderStatus.defaultExpectation != nil {
		mmSetOrderStatus.mock.t.Fatalf("Default expectation is already set for the OrdersHistoryRepository.SetOrderStatus method")
	}

	if len(mmSetOrderStatus.expectations) > 0 {
		mmSetOrderStatus.mock.t.Fatalf("Some expectations are already set for the OrdersHistoryRepository.SetOrderStatus method")
	}

	mmSetOrderStatus.mock.funcSetOrderStatus = f
	mmSetOrderStatus.mock.funcSetOrderStatusOrigin = minimock.CallerInfo(1)
	return mmSetOrderStatus.mock
}

// When sets expectation for the OrdersHistoryRepository.SetOrderStatus which will trigger the result defined by the following
// Then helper
func (mmSetOrderStatus *mOrdersHistoryRepositoryMockSetOrderStatus) When(orderID uint64, status string) *OrdersHistoryRepositoryMockSetOrderStatusExpectation {
	if mmSetOrderStatus.mock.funcSetOrderStatus != nil {
		mmSetOrderStatus.mock.t.Fatalf("OrdersHistoryRepositoryMock.SetOrderStatus mock is already set by Set")
	}

	expectation := &OrdersHistoryRepositoryMockSetOrderStatusExpectation{
		mock:               mmSetOrderStatus.mock,
		params:             &OrdersHistoryRepositoryMockSetOrderStatusParams{orderID, status},
		expectationOrigins: OrdersHistoryRepositoryMockSetOrderStatusExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetOrderStatus.expectations = append(mmSetOrderStatus.expectations, expectation)
	return expectation
}

// Then sets up OrdersHistoryRepository.SetOrderStatus return parameters for the expectation previously defined by the When method
func (e *OrdersHistoryRepositoryMockSetOrderStatusExpectation) Then(err error) *OrdersHistoryRepositoryMock {
	e.results = &OrdersHistoryRepositoryMockSetOrderStatusResults{err}
	return e.mock
}

// Times sets number of times OrdersHistoryRepository.SetOrderStatus should be invoked
func (mmSetOrderStatus *mOrdersHistoryRepositoryMockSetOrderStatus) Times(n uint64) *mOrdersHistoryRepositoryMockSetOrderStatus {
	if n == 0 {
		mmSetOrderStatus.mock.t.Fatalf("Times of OrdersHistoryRepositoryMock.SetOrderStatus mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetOrderStatus.expectedInvocations, n)
	mmSetOrderStatus.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetOrderStatus
}

func (mmSetOrderStatus *mOrdersHistoryRepositoryMockSetOrderStatus) invocationsDone() bool {
	if len(mmSetOrderStatus.expectations) == 0 && mmSetOrderStatus.defaultExpectation == nil && mmSetOrderStatus.mock.funcSetOrderStatus == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetOrderStatus.mock.afterSetOrderStatusCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetOrderStatus.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetOrderStatus implements mm_storage.OrdersHistoryRepository
func (mmSetOrderStatus *OrdersHistoryRepositoryMock) SetOrderStatus(orderID uint64, status string) (err error) {
	mm_atomic.AddUint64(&mmSetOrderStatus.beforeSetOrderStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmSetOrderStatus.afterSetOrderStatusCounter, 1)

	mmSetOrderStatus.t.Helper()

	if mmSetOrderStatus.inspectFuncSetOrderStatus != nil {
		mmSetOrderStatus.inspectFuncSetOrderStatus(orderID, status)
	}

	mm_params := OrdersHistoryRepositoryMockSetOrderStatusParams{orderID, status}

	// Record call args
	mmSetOrderStatus.SetOrderStatusMock.mutex.Lock()
	mmSetOrderStatus.SetOrderStatusMock.callArgs = append(mmSetOrderStatus.SetOrderStatusMock.callArgs, &mm_params)
	mmSetOrderStatus.SetOrderStatusMock.mutex.Unlock()

	for _, e := range mmSetOrderStatus.SetOrderStatusMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetOrderStatus.SetOrderStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetOrderStatus.SetOrderStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmSetOrderStatus.SetOrderStatusMock.defaultExpectation.params
		mm_want_ptrs := mmSetOrderStatus.SetOrderStatusMock.defaultExpectation.paramPtrs

		mm_got := OrdersHistoryRepositoryMockSetOrderStatusParams{orderID, status}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmSetOrderStatus.t.Errorf("OrdersHistoryRepositoryMock.SetOrderStatus got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetOrderStatus.SetOrderStatusMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

			if mm_want_ptrs.status != nil && !minimock.Equal(*mm_want_ptrs.status, mm_got.status) {
				mmSetOrderStatus.t.Errorf("OrdersHistoryRepositoryMock.SetOrderStatus got unexpected parameter status, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetOrderStatus.SetOrderStatusMock.defaultExpectation.expectationOrigins.originStatus, *mm_want_ptrs.status, mm_got.status, minimock.Diff(*mm_want_ptrs.status, mm_got.status))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetOrderStatus.t.Errorf("OrdersHistoryRepositoryMock.SetOrderStatus got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetOrderStatus.SetOrderStatusMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetOrderStatus.SetOrderStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmSetOrderStatus.t.Fatal("No results are set for the OrdersHistoryRepositoryMock.SetOrderStatus")
		}
		return (*mm_results).err
	}
	if mmSetOrderStatus.funcSetOrderStatus != nil {
		return mmSetOrderStatus.funcSetOrderStatus(orderID, status)
	}
	mmSetOrderStatus.t.Fatalf("Unexpected call to OrdersHistoryRepositoryMock.SetOrderStatus. %v %v", orderID, status)
	return
}

// SetOrderStatusAfterCounter returns a count of finished OrdersHistoryRepositoryMock.SetOrderStatus invocations
func (mmSetOrderStatus *OrdersHistoryRepositoryMock) SetOrderStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetOrderStatus.afterSetOrderStatusCounter)
}

// SetOrderStatusBeforeCounter returns a count of OrdersHistoryRepositoryMock.SetOrderStatus invocations
func (mmSetOrderStatus *OrdersHistoryRepositoryMock) SetOrderStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetOrderStatus.beforeSetOrderStatusCounter)
}

// Calls returns a list of arguments used in each call to OrdersHistoryRepositoryMock.SetOrderStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetOrderStatus *mOrdersHistoryRepositoryMockSetOrderStatus) Calls() []*OrdersHistoryRepositoryMockSetOrderStatusParams {
	mmSetOrderStatus.mutex.RLock()

	argCopy := make([]*OrdersHistoryRepositoryMockSetOrderStatusParams, len(mmSetOrderStatus.callArgs))
	copy(argCopy, mmSetOrderStatus.callArgs)

	mmSetOrderStatus.mutex.RUnlock()

	return argCopy
}

// MinimockSetOrderStatusDone returns true if the count of the SetOrderStatus invocations corresponds
// the number of defined expectations
func (m *OrdersHistoryRepositoryMock) MinimockSetOrderStatusDone() bool {
	if m.SetOrderStatusMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetOrderStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetOrderStatusMock.invocationsDone()
}

// MinimockSetOrderStatusInspect logs each unmet expectation
func (m *OrdersHistoryRepositoryMock) MinimockSetOrderStatusInspect() {
	for _, e := range m.SetOrderStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrdersHistoryRepositoryMock.SetOrderStatus at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetOrderStatusCounter := mm_atomic.LoadUint64(&m.afterSetOrderStatusCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetOrderStatusMock.defaultExpectation != nil && afterSetOrderStatusCounter < 1 {
		if m.SetOrderStatusMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrdersHistoryRepositoryMock.SetOrderStatus at\n%s", m.SetOrderStatusMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrdersHistoryRepositoryMock.SetOrderStatus at\n%s with params: %#v", m.SetOrderStatusMock.defaultExpectation.expectationOrigins.origin, *m.SetOrderStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetOrderStatus != nil && afterSetOrderStatusCounter < 1 {
		m.t.Errorf("Expected call to OrdersHistoryRepositoryMock.SetOrderStatus at\n%s", m.funcSetOrderStatusOrigin)
	}

	if !m.SetOrderStatusMock.invocationsDone() && afterSetOrderStatusCounter > 0 {
		m.t.Errorf("Expected %d calls to OrdersHistoryRepositoryMock.SetOrderStatus at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetOrderStatusMock.expectedInvocations), m.SetOrderStatusMock.expectedInvocationsOrigin, afterSetOrderStatusCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OrdersHistoryRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddOrderStatusInspect()

			m.MinimockGetOrderStatusInspect()

			m.MinimockSetOrderStatusInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OrdersHistoryRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *OrdersHistoryRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddOrderStatusDone() &&
		m.MinimockGetOrderStatusDone() &&
		m.MinimockSetOrderStatusDone()
}
