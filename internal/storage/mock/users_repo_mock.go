// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mock

//go:generate minimock -i gitlab.ozon.dev/chppppr/homework/internal/storage.UsersRepository -o users_repo_mock.go -n UsersRepositoryMock -p mock

import (
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.ozon.dev/chppppr/homework/internal/domain"
)

// UsersRepositoryMock implements mm_storage.UsersRepository
type UsersRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddOrder          func(userID uint64, orderID uint64, order *domain.Order) (err error)
	funcAddOrderOrigin    string
	inspectFuncAddOrder   func(userID uint64, orderID uint64, order *domain.Order)
	afterAddOrderCounter  uint64
	beforeAddOrderCounter uint64
	AddOrderMock          mUsersRepositoryMockAddOrder

	funcCanRemove          func(userID uint64, orderID uint64) (err error)
	funcCanRemoveOrigin    string
	inspectFuncCanRemove   func(userID uint64, orderID uint64)
	afterCanRemoveCounter  uint64
	beforeCanRemoveCounter uint64
	CanRemoveMock          mUsersRepositoryMockCanRemove

	funcGetExpirationDate          func(userID uint64, orderID uint64) (t1 time.Time, err error)
	funcGetExpirationDateOrigin    string
	inspectFuncGetExpirationDate   func(userID uint64, orderID uint64)
	afterGetExpirationDateCounter  uint64
	beforeGetExpirationDateCounter uint64
	GetExpirationDateMock          mUsersRepositoryMockGetExpirationDate

	funcGetOrder          func(userID uint64, orderID uint64) (op1 *domain.Order, err error)
	funcGetOrderOrigin    string
	inspectFuncGetOrder   func(userID uint64, orderID uint64)
	afterGetOrderCounter  uint64
	beforeGetOrderCounter uint64
	GetOrderMock          mUsersRepositoryMockGetOrder

	funcGetOrders          func(userID uint64, firstOrderID uint64, limit uint64) (oa1 []domain.OrderView, err error)
	funcGetOrdersOrigin    string
	inspectFuncGetOrders   func(userID uint64, firstOrderID uint64, limit uint64)
	afterGetOrdersCounter  uint64
	beforeGetOrdersCounter uint64
	GetOrdersMock          mUsersRepositoryMockGetOrders

	funcRemoveOrder          func(userID uint64, orderID uint64) (err error)
	funcRemoveOrderOrigin    string
	inspectFuncRemoveOrder   func(userID uint64, orderID uint64)
	afterRemoveOrderCounter  uint64
	beforeRemoveOrderCounter uint64
	RemoveOrderMock          mUsersRepositoryMockRemoveOrder
}

// NewUsersRepositoryMock returns a mock for mm_storage.UsersRepository
func NewUsersRepositoryMock(t minimock.Tester) *UsersRepositoryMock {
	m := &UsersRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddOrderMock = mUsersRepositoryMockAddOrder{mock: m}
	m.AddOrderMock.callArgs = []*UsersRepositoryMockAddOrderParams{}

	m.CanRemoveMock = mUsersRepositoryMockCanRemove{mock: m}
	m.CanRemoveMock.callArgs = []*UsersRepositoryMockCanRemoveParams{}

	m.GetExpirationDateMock = mUsersRepositoryMockGetExpirationDate{mock: m}
	m.GetExpirationDateMock.callArgs = []*UsersRepositoryMockGetExpirationDateParams{}

	m.GetOrderMock = mUsersRepositoryMockGetOrder{mock: m}
	m.GetOrderMock.callArgs = []*UsersRepositoryMockGetOrderParams{}

	m.GetOrdersMock = mUsersRepositoryMockGetOrders{mock: m}
	m.GetOrdersMock.callArgs = []*UsersRepositoryMockGetOrdersParams{}

	m.RemoveOrderMock = mUsersRepositoryMockRemoveOrder{mock: m}
	m.RemoveOrderMock.callArgs = []*UsersRepositoryMockRemoveOrderParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mUsersRepositoryMockAddOrder struct {
	optional           bool
	mock               *UsersRepositoryMock
	defaultExpectation *UsersRepositoryMockAddOrderExpectation
	expectations       []*UsersRepositoryMockAddOrderExpectation

	callArgs []*UsersRepositoryMockAddOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UsersRepositoryMockAddOrderExpectation specifies expectation struct of the UsersRepository.AddOrder
type UsersRepositoryMockAddOrderExpectation struct {
	mock               *UsersRepositoryMock
	params             *UsersRepositoryMockAddOrderParams
	paramPtrs          *UsersRepositoryMockAddOrderParamPtrs
	expectationOrigins UsersRepositoryMockAddOrderExpectationOrigins
	results            *UsersRepositoryMockAddOrderResults
	returnOrigin       string
	Counter            uint64
}

// UsersRepositoryMockAddOrderParams contains parameters of the UsersRepository.AddOrder
type UsersRepositoryMockAddOrderParams struct {
	userID  uint64
	orderID uint64
	order   *domain.Order
}

// UsersRepositoryMockAddOrderParamPtrs contains pointers to parameters of the UsersRepository.AddOrder
type UsersRepositoryMockAddOrderParamPtrs struct {
	userID  *uint64
	orderID *uint64
	order   **domain.Order
}

// UsersRepositoryMockAddOrderResults contains results of the UsersRepository.AddOrder
type UsersRepositoryMockAddOrderResults struct {
	err error
}

// UsersRepositoryMockAddOrderOrigins contains origins of expectations of the UsersRepository.AddOrder
type UsersRepositoryMockAddOrderExpectationOrigins struct {
	origin        string
	originUserID  string
	originOrderID string
	originOrder   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddOrder *mUsersRepositoryMockAddOrder) Optional() *mUsersRepositoryMockAddOrder {
	mmAddOrder.optional = true
	return mmAddOrder
}

// Expect sets up expected params for UsersRepository.AddOrder
func (mmAddOrder *mUsersRepositoryMockAddOrder) Expect(userID uint64, orderID uint64, order *domain.Order) *mUsersRepositoryMockAddOrder {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("UsersRepositoryMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &UsersRepositoryMockAddOrderExpectation{}
	}

	if mmAddOrder.defaultExpectation.paramPtrs != nil {
		mmAddOrder.mock.t.Fatalf("UsersRepositoryMock.AddOrder mock is already set by ExpectParams functions")
	}

	mmAddOrder.defaultExpectation.params = &UsersRepositoryMockAddOrderParams{userID, orderID, order}
	mmAddOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddOrder.expectations {
		if minimock.Equal(e.params, mmAddOrder.defaultExpectation.params) {
			mmAddOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddOrder.defaultExpectation.params)
		}
	}

	return mmAddOrder
}

// ExpectUserIDParam1 sets up expected param userID for UsersRepository.AddOrder
func (mmAddOrder *mUsersRepositoryMockAddOrder) ExpectUserIDParam1(userID uint64) *mUsersRepositoryMockAddOrder {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("UsersRepositoryMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &UsersRepositoryMockAddOrderExpectation{}
	}

	if mmAddOrder.defaultExpectation.params != nil {
		mmAddOrder.mock.t.Fatalf("UsersRepositoryMock.AddOrder mock is already set by Expect")
	}

	if mmAddOrder.defaultExpectation.paramPtrs == nil {
		mmAddOrder.defaultExpectation.paramPtrs = &UsersRepositoryMockAddOrderParamPtrs{}
	}
	mmAddOrder.defaultExpectation.paramPtrs.userID = &userID
	mmAddOrder.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmAddOrder
}

// ExpectOrderIDParam2 sets up expected param orderID for UsersRepository.AddOrder
func (mmAddOrder *mUsersRepositoryMockAddOrder) ExpectOrderIDParam2(orderID uint64) *mUsersRepositoryMockAddOrder {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("UsersRepositoryMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &UsersRepositoryMockAddOrderExpectation{}
	}

	if mmAddOrder.defaultExpectation.params != nil {
		mmAddOrder.mock.t.Fatalf("UsersRepositoryMock.AddOrder mock is already set by Expect")
	}

	if mmAddOrder.defaultExpectation.paramPtrs == nil {
		mmAddOrder.defaultExpectation.paramPtrs = &UsersRepositoryMockAddOrderParamPtrs{}
	}
	mmAddOrder.defaultExpectation.paramPtrs.orderID = &orderID
	mmAddOrder.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmAddOrder
}

// ExpectOrderParam3 sets up expected param order for UsersRepository.AddOrder
func (mmAddOrder *mUsersRepositoryMockAddOrder) ExpectOrderParam3(order *domain.Order) *mUsersRepositoryMockAddOrder {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("UsersRepositoryMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &UsersRepositoryMockAddOrderExpectation{}
	}

	if mmAddOrder.defaultExpectation.params != nil {
		mmAddOrder.mock.t.Fatalf("UsersRepositoryMock.AddOrder mock is already set by Expect")
	}

	if mmAddOrder.defaultExpectation.paramPtrs == nil {
		mmAddOrder.defaultExpectation.paramPtrs = &UsersRepositoryMockAddOrderParamPtrs{}
	}
	mmAddOrder.defaultExpectation.paramPtrs.order = &order
	mmAddOrder.defaultExpectation.expectationOrigins.originOrder = minimock.CallerInfo(1)

	return mmAddOrder
}

// Inspect accepts an inspector function that has same arguments as the UsersRepository.AddOrder
func (mmAddOrder *mUsersRepositoryMockAddOrder) Inspect(f func(userID uint64, orderID uint64, order *domain.Order)) *mUsersRepositoryMockAddOrder {
	if mmAddOrder.mock.inspectFuncAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("Inspect function is already set for UsersRepositoryMock.AddOrder")
	}

	mmAddOrder.mock.inspectFuncAddOrder = f

	return mmAddOrder
}

// Return sets up results that will be returned by UsersRepository.AddOrder
func (mmAddOrder *mUsersRepositoryMockAddOrder) Return(err error) *UsersRepositoryMock {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("UsersRepositoryMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &UsersRepositoryMockAddOrderExpectation{mock: mmAddOrder.mock}
	}
	mmAddOrder.defaultExpectation.results = &UsersRepositoryMockAddOrderResults{err}
	mmAddOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddOrder.mock
}

// Set uses given function f to mock the UsersRepository.AddOrder method
func (mmAddOrder *mUsersRepositoryMockAddOrder) Set(f func(userID uint64, orderID uint64, order *domain.Order) (err error)) *UsersRepositoryMock {
	if mmAddOrder.defaultExpectation != nil {
		mmAddOrder.mock.t.Fatalf("Default expectation is already set for the UsersRepository.AddOrder method")
	}

	if len(mmAddOrder.expectations) > 0 {
		mmAddOrder.mock.t.Fatalf("Some expectations are already set for the UsersRepository.AddOrder method")
	}

	mmAddOrder.mock.funcAddOrder = f
	mmAddOrder.mock.funcAddOrderOrigin = minimock.CallerInfo(1)
	return mmAddOrder.mock
}

// When sets expectation for the UsersRepository.AddOrder which will trigger the result defined by the following
// Then helper
func (mmAddOrder *mUsersRepositoryMockAddOrder) When(userID uint64, orderID uint64, order *domain.Order) *UsersRepositoryMockAddOrderExpectation {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("UsersRepositoryMock.AddOrder mock is already set by Set")
	}

	expectation := &UsersRepositoryMockAddOrderExpectation{
		mock:               mmAddOrder.mock,
		params:             &UsersRepositoryMockAddOrderParams{userID, orderID, order},
		expectationOrigins: UsersRepositoryMockAddOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddOrder.expectations = append(mmAddOrder.expectations, expectation)
	return expectation
}

// Then sets up UsersRepository.AddOrder return parameters for the expectation previously defined by the When method
func (e *UsersRepositoryMockAddOrderExpectation) Then(err error) *UsersRepositoryMock {
	e.results = &UsersRepositoryMockAddOrderResults{err}
	return e.mock
}

// Times sets number of times UsersRepository.AddOrder should be invoked
func (mmAddOrder *mUsersRepositoryMockAddOrder) Times(n uint64) *mUsersRepositoryMockAddOrder {
	if n == 0 {
		mmAddOrder.mock.t.Fatalf("Times of UsersRepositoryMock.AddOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddOrder.expectedInvocations, n)
	mmAddOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddOrder
}

func (mmAddOrder *mUsersRepositoryMockAddOrder) invocationsDone() bool {
	if len(mmAddOrder.expectations) == 0 && mmAddOrder.defaultExpectation == nil && mmAddOrder.mock.funcAddOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddOrder.mock.afterAddOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddOrder implements mm_storage.UsersRepository
func (mmAddOrder *UsersRepositoryMock) AddOrder(userID uint64, orderID uint64, order *domain.Order) (err error) {
	mm_atomic.AddUint64(&mmAddOrder.beforeAddOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmAddOrder.afterAddOrderCounter, 1)

	mmAddOrder.t.Helper()

	if mmAddOrder.inspectFuncAddOrder != nil {
		mmAddOrder.inspectFuncAddOrder(userID, orderID, order)
	}

	mm_params := UsersRepositoryMockAddOrderParams{userID, orderID, order}

	// Record call args
	mmAddOrder.AddOrderMock.mutex.Lock()
	mmAddOrder.AddOrderMock.callArgs = append(mmAddOrder.AddOrderMock.callArgs, &mm_params)
	mmAddOrder.AddOrderMock.mutex.Unlock()

	for _, e := range mmAddOrder.AddOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddOrder.AddOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddOrder.AddOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmAddOrder.AddOrderMock.defaultExpectation.params
		mm_want_ptrs := mmAddOrder.AddOrderMock.defaultExpectation.paramPtrs

		mm_got := UsersRepositoryMockAddOrderParams{userID, orderID, order}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmAddOrder.t.Errorf("UsersRepositoryMock.AddOrder got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddOrder.AddOrderMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmAddOrder.t.Errorf("UsersRepositoryMock.AddOrder got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddOrder.AddOrderMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmAddOrder.t.Errorf("UsersRepositoryMock.AddOrder got unexpected parameter order, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddOrder.AddOrderMock.defaultExpectation.expectationOrigins.originOrder, *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddOrder.t.Errorf("UsersRepositoryMock.AddOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddOrder.AddOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddOrder.AddOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmAddOrder.t.Fatal("No results are set for the UsersRepositoryMock.AddOrder")
		}
		return (*mm_results).err
	}
	if mmAddOrder.funcAddOrder != nil {
		return mmAddOrder.funcAddOrder(userID, orderID, order)
	}
	mmAddOrder.t.Fatalf("Unexpected call to UsersRepositoryMock.AddOrder. %v %v %v", userID, orderID, order)
	return
}

// AddOrderAfterCounter returns a count of finished UsersRepositoryMock.AddOrder invocations
func (mmAddOrder *UsersRepositoryMock) AddOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddOrder.afterAddOrderCounter)
}

// AddOrderBeforeCounter returns a count of UsersRepositoryMock.AddOrder invocations
func (mmAddOrder *UsersRepositoryMock) AddOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddOrder.beforeAddOrderCounter)
}

// Calls returns a list of arguments used in each call to UsersRepositoryMock.AddOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddOrder *mUsersRepositoryMockAddOrder) Calls() []*UsersRepositoryMockAddOrderParams {
	mmAddOrder.mutex.RLock()

	argCopy := make([]*UsersRepositoryMockAddOrderParams, len(mmAddOrder.callArgs))
	copy(argCopy, mmAddOrder.callArgs)

	mmAddOrder.mutex.RUnlock()

	return argCopy
}

// MinimockAddOrderDone returns true if the count of the AddOrder invocations corresponds
// the number of defined expectations
func (m *UsersRepositoryMock) MinimockAddOrderDone() bool {
	if m.AddOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddOrderMock.invocationsDone()
}

// MinimockAddOrderInspect logs each unmet expectation
func (m *UsersRepositoryMock) MinimockAddOrderInspect() {
	for _, e := range m.AddOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UsersRepositoryMock.AddOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddOrderCounter := mm_atomic.LoadUint64(&m.afterAddOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddOrderMock.defaultExpectation != nil && afterAddOrderCounter < 1 {
		if m.AddOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UsersRepositoryMock.AddOrder at\n%s", m.AddOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UsersRepositoryMock.AddOrder at\n%s with params: %#v", m.AddOrderMock.defaultExpectation.expectationOrigins.origin, *m.AddOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddOrder != nil && afterAddOrderCounter < 1 {
		m.t.Errorf("Expected call to UsersRepositoryMock.AddOrder at\n%s", m.funcAddOrderOrigin)
	}

	if !m.AddOrderMock.invocationsDone() && afterAddOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to UsersRepositoryMock.AddOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddOrderMock.expectedInvocations), m.AddOrderMock.expectedInvocationsOrigin, afterAddOrderCounter)
	}
}

type mUsersRepositoryMockCanRemove struct {
	optional           bool
	mock               *UsersRepositoryMock
	defaultExpectation *UsersRepositoryMockCanRemoveExpectation
	expectations       []*UsersRepositoryMockCanRemoveExpectation

	callArgs []*UsersRepositoryMockCanRemoveParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UsersRepositoryMockCanRemoveExpectation specifies expectation struct of the UsersRepository.CanRemove
type UsersRepositoryMockCanRemoveExpectation struct {
	mock               *UsersRepositoryMock
	params             *UsersRepositoryMockCanRemoveParams
	paramPtrs          *UsersRepositoryMockCanRemoveParamPtrs
	expectationOrigins UsersRepositoryMockCanRemoveExpectationOrigins
	results            *UsersRepositoryMockCanRemoveResults
	returnOrigin       string
	Counter            uint64
}

// UsersRepositoryMockCanRemoveParams contains parameters of the UsersRepository.CanRemove
type UsersRepositoryMockCanRemoveParams struct {
	userID  uint64
	orderID uint64
}

// UsersRepositoryMockCanRemoveParamPtrs contains pointers to parameters of the UsersRepository.CanRemove
type UsersRepositoryMockCanRemoveParamPtrs struct {
	userID  *uint64
	orderID *uint64
}

// UsersRepositoryMockCanRemoveResults contains results of the UsersRepository.CanRemove
type UsersRepositoryMockCanRemoveResults struct {
	err error
}

// UsersRepositoryMockCanRemoveOrigins contains origins of expectations of the UsersRepository.CanRemove
type UsersRepositoryMockCanRemoveExpectationOrigins struct {
	origin        string
	originUserID  string
	originOrderID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCanRemove *mUsersRepositoryMockCanRemove) Optional() *mUsersRepositoryMockCanRemove {
	mmCanRemove.optional = true
	return mmCanRemove
}

// Expect sets up expected params for UsersRepository.CanRemove
func (mmCanRemove *mUsersRepositoryMockCanRemove) Expect(userID uint64, orderID uint64) *mUsersRepositoryMockCanRemove {
	if mmCanRemove.mock.funcCanRemove != nil {
		mmCanRemove.mock.t.Fatalf("UsersRepositoryMock.CanRemove mock is already set by Set")
	}

	if mmCanRemove.defaultExpectation == nil {
		mmCanRemove.defaultExpectation = &UsersRepositoryMockCanRemoveExpectation{}
	}

	if mmCanRemove.defaultExpectation.paramPtrs != nil {
		mmCanRemove.mock.t.Fatalf("UsersRepositoryMock.CanRemove mock is already set by ExpectParams functions")
	}

	mmCanRemove.defaultExpectation.params = &UsersRepositoryMockCanRemoveParams{userID, orderID}
	mmCanRemove.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCanRemove.expectations {
		if minimock.Equal(e.params, mmCanRemove.defaultExpectation.params) {
			mmCanRemove.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCanRemove.defaultExpectation.params)
		}
	}

	return mmCanRemove
}

// ExpectUserIDParam1 sets up expected param userID for UsersRepository.CanRemove
func (mmCanRemove *mUsersRepositoryMockCanRemove) ExpectUserIDParam1(userID uint64) *mUsersRepositoryMockCanRemove {
	if mmCanRemove.mock.funcCanRemove != nil {
		mmCanRemove.mock.t.Fatalf("UsersRepositoryMock.CanRemove mock is already set by Set")
	}

	if mmCanRemove.defaultExpectation == nil {
		mmCanRemove.defaultExpectation = &UsersRepositoryMockCanRemoveExpectation{}
	}

	if mmCanRemove.defaultExpectation.params != nil {
		mmCanRemove.mock.t.Fatalf("UsersRepositoryMock.CanRemove mock is already set by Expect")
	}

	if mmCanRemove.defaultExpectation.paramPtrs == nil {
		mmCanRemove.defaultExpectation.paramPtrs = &UsersRepositoryMockCanRemoveParamPtrs{}
	}
	mmCanRemove.defaultExpectation.paramPtrs.userID = &userID
	mmCanRemove.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmCanRemove
}

// ExpectOrderIDParam2 sets up expected param orderID for UsersRepository.CanRemove
func (mmCanRemove *mUsersRepositoryMockCanRemove) ExpectOrderIDParam2(orderID uint64) *mUsersRepositoryMockCanRemove {
	if mmCanRemove.mock.funcCanRemove != nil {
		mmCanRemove.mock.t.Fatalf("UsersRepositoryMock.CanRemove mock is already set by Set")
	}

	if mmCanRemove.defaultExpectation == nil {
		mmCanRemove.defaultExpectation = &UsersRepositoryMockCanRemoveExpectation{}
	}

	if mmCanRemove.defaultExpectation.params != nil {
		mmCanRemove.mock.t.Fatalf("UsersRepositoryMock.CanRemove mock is already set by Expect")
	}

	if mmCanRemove.defaultExpectation.paramPtrs == nil {
		mmCanRemove.defaultExpectation.paramPtrs = &UsersRepositoryMockCanRemoveParamPtrs{}
	}
	mmCanRemove.defaultExpectation.paramPtrs.orderID = &orderID
	mmCanRemove.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmCanRemove
}

// Inspect accepts an inspector function that has same arguments as the UsersRepository.CanRemove
func (mmCanRemove *mUsersRepositoryMockCanRemove) Inspect(f func(userID uint64, orderID uint64)) *mUsersRepositoryMockCanRemove {
	if mmCanRemove.mock.inspectFuncCanRemove != nil {
		mmCanRemove.mock.t.Fatalf("Inspect function is already set for UsersRepositoryMock.CanRemove")
	}

	mmCanRemove.mock.inspectFuncCanRemove = f

	return mmCanRemove
}

// Return sets up results that will be returned by UsersRepository.CanRemove
func (mmCanRemove *mUsersRepositoryMockCanRemove) Return(err error) *UsersRepositoryMock {
	if mmCanRemove.mock.funcCanRemove != nil {
		mmCanRemove.mock.t.Fatalf("UsersRepositoryMock.CanRemove mock is already set by Set")
	}

	if mmCanRemove.defaultExpectation == nil {
		mmCanRemove.defaultExpectation = &UsersRepositoryMockCanRemoveExpectation{mock: mmCanRemove.mock}
	}
	mmCanRemove.defaultExpectation.results = &UsersRepositoryMockCanRemoveResults{err}
	mmCanRemove.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCanRemove.mock
}

// Set uses given function f to mock the UsersRepository.CanRemove method
func (mmCanRemove *mUsersRepositoryMockCanRemove) Set(f func(userID uint64, orderID uint64) (err error)) *UsersRepositoryMock {
	if mmCanRemove.defaultExpectation != nil {
		mmCanRemove.mock.t.Fatalf("Default expectation is already set for the UsersRepository.CanRemove method")
	}

	if len(mmCanRemove.expectations) > 0 {
		mmCanRemove.mock.t.Fatalf("Some expectations are already set for the UsersRepository.CanRemove method")
	}

	mmCanRemove.mock.funcCanRemove = f
	mmCanRemove.mock.funcCanRemoveOrigin = minimock.CallerInfo(1)
	return mmCanRemove.mock
}

// When sets expectation for the UsersRepository.CanRemove which will trigger the result defined by the following
// Then helper
func (mmCanRemove *mUsersRepositoryMockCanRemove) When(userID uint64, orderID uint64) *UsersRepositoryMockCanRemoveExpectation {
	if mmCanRemove.mock.funcCanRemove != nil {
		mmCanRemove.mock.t.Fatalf("UsersRepositoryMock.CanRemove mock is already set by Set")
	}

	expectation := &UsersRepositoryMockCanRemoveExpectation{
		mock:               mmCanRemove.mock,
		params:             &UsersRepositoryMockCanRemoveParams{userID, orderID},
		expectationOrigins: UsersRepositoryMockCanRemoveExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCanRemove.expectations = append(mmCanRemove.expectations, expectation)
	return expectation
}

// Then sets up UsersRepository.CanRemove return parameters for the expectation previously defined by the When method
func (e *UsersRepositoryMockCanRemoveExpectation) Then(err error) *UsersRepositoryMock {
	e.results = &UsersRepositoryMockCanRemoveResults{err}
	return e.mock
}

// Times sets number of times UsersRepository.CanRemove should be invoked
func (mmCanRemove *mUsersRepositoryMockCanRemove) Times(n uint64) *mUsersRepositoryMockCanRemove {
	if n == 0 {
		mmCanRemove.mock.t.Fatalf("Times of UsersRepositoryMock.CanRemove mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCanRemove.expectedInvocations, n)
	mmCanRemove.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCanRemove
}

func (mmCanRemove *mUsersRepositoryMockCanRemove) invocationsDone() bool {
	if len(mmCanRemove.expectations) == 0 && mmCanRemove.defaultExpectation == nil && mmCanRemove.mock.funcCanRemove == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCanRemove.mock.afterCanRemoveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCanRemove.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CanRemove implements mm_storage.UsersRepository
func (mmCanRemove *UsersRepositoryMock) CanRemove(userID uint64, orderID uint64) (err error) {
	mm_atomic.AddUint64(&mmCanRemove.beforeCanRemoveCounter, 1)
	defer mm_atomic.AddUint64(&mmCanRemove.afterCanRemoveCounter, 1)

	mmCanRemove.t.Helper()

	if mmCanRemove.inspectFuncCanRemove != nil {
		mmCanRemove.inspectFuncCanRemove(userID, orderID)
	}

	mm_params := UsersRepositoryMockCanRemoveParams{userID, orderID}

	// Record call args
	mmCanRemove.CanRemoveMock.mutex.Lock()
	mmCanRemove.CanRemoveMock.callArgs = append(mmCanRemove.CanRemoveMock.callArgs, &mm_params)
	mmCanRemove.CanRemoveMock.mutex.Unlock()

	for _, e := range mmCanRemove.CanRemoveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCanRemove.CanRemoveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCanRemove.CanRemoveMock.defaultExpectation.Counter, 1)
		mm_want := mmCanRemove.CanRemoveMock.defaultExpectation.params
		mm_want_ptrs := mmCanRemove.CanRemoveMock.defaultExpectation.paramPtrs

		mm_got := UsersRepositoryMockCanRemoveParams{userID, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmCanRemove.t.Errorf("UsersRepositoryMock.CanRemove got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCanRemove.CanRemoveMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmCanRemove.t.Errorf("UsersRepositoryMock.CanRemove got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCanRemove.CanRemoveMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCanRemove.t.Errorf("UsersRepositoryMock.CanRemove got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCanRemove.CanRemoveMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCanRemove.CanRemoveMock.defaultExpectation.results
		if mm_results == nil {
			mmCanRemove.t.Fatal("No results are set for the UsersRepositoryMock.CanRemove")
		}
		return (*mm_results).err
	}
	if mmCanRemove.funcCanRemove != nil {
		return mmCanRemove.funcCanRemove(userID, orderID)
	}
	mmCanRemove.t.Fatalf("Unexpected call to UsersRepositoryMock.CanRemove. %v %v", userID, orderID)
	return
}

// CanRemoveAfterCounter returns a count of finished UsersRepositoryMock.CanRemove invocations
func (mmCanRemove *UsersRepositoryMock) CanRemoveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCanRemove.afterCanRemoveCounter)
}

// CanRemoveBeforeCounter returns a count of UsersRepositoryMock.CanRemove invocations
func (mmCanRemove *UsersRepositoryMock) CanRemoveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCanRemove.beforeCanRemoveCounter)
}

// Calls returns a list of arguments used in each call to UsersRepositoryMock.CanRemove.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCanRemove *mUsersRepositoryMockCanRemove) Calls() []*UsersRepositoryMockCanRemoveParams {
	mmCanRemove.mutex.RLock()

	argCopy := make([]*UsersRepositoryMockCanRemoveParams, len(mmCanRemove.callArgs))
	copy(argCopy, mmCanRemove.callArgs)

	mmCanRemove.mutex.RUnlock()

	return argCopy
}

// MinimockCanRemoveDone returns true if the count of the CanRemove invocations corresponds
// the number of defined expectations
func (m *UsersRepositoryMock) MinimockCanRemoveDone() bool {
	if m.CanRemoveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CanRemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CanRemoveMock.invocationsDone()
}

// MinimockCanRemoveInspect logs each unmet expectation
func (m *UsersRepositoryMock) MinimockCanRemoveInspect() {
	for _, e := range m.CanRemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UsersRepositoryMock.CanRemove at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCanRemoveCounter := mm_atomic.LoadUint64(&m.afterCanRemoveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CanRemoveMock.defaultExpectation != nil && afterCanRemoveCounter < 1 {
		if m.CanRemoveMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UsersRepositoryMock.CanRemove at\n%s", m.CanRemoveMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UsersRepositoryMock.CanRemove at\n%s with params: %#v", m.CanRemoveMock.defaultExpectation.expectationOrigins.origin, *m.CanRemoveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCanRemove != nil && afterCanRemoveCounter < 1 {
		m.t.Errorf("Expected call to UsersRepositoryMock.CanRemove at\n%s", m.funcCanRemoveOrigin)
	}

	if !m.CanRemoveMock.invocationsDone() && afterCanRemoveCounter > 0 {
		m.t.Errorf("Expected %d calls to UsersRepositoryMock.CanRemove at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CanRemoveMock.expectedInvocations), m.CanRemoveMock.expectedInvocationsOrigin, afterCanRemoveCounter)
	}
}

type mUsersRepositoryMockGetExpirationDate struct {
	optional           bool
	mock               *UsersRepositoryMock
	defaultExpectation *UsersRepositoryMockGetExpirationDateExpectation
	expectations       []*UsersRepositoryMockGetExpirationDateExpectation

	callArgs []*UsersRepositoryMockGetExpirationDateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UsersRepositoryMockGetExpirationDateExpectation specifies expectation struct of the UsersRepository.GetExpirationDate
type UsersRepositoryMockGetExpirationDateExpectation struct {
	mock               *UsersRepositoryMock
	params             *UsersRepositoryMockGetExpirationDateParams
	paramPtrs          *UsersRepositoryMockGetExpirationDateParamPtrs
	expectationOrigins UsersRepositoryMockGetExpirationDateExpectationOrigins
	results            *UsersRepositoryMockGetExpirationDateResults
	returnOrigin       string
	Counter            uint64
}

// UsersRepositoryMockGetExpirationDateParams contains parameters of the UsersRepository.GetExpirationDate
type UsersRepositoryMockGetExpirationDateParams struct {
	userID  uint64
	orderID uint64
}

// UsersRepositoryMockGetExpirationDateParamPtrs contains pointers to parameters of the UsersRepository.GetExpirationDate
type UsersRepositoryMockGetExpirationDateParamPtrs struct {
	userID  *uint64
	orderID *uint64
}

// UsersRepositoryMockGetExpirationDateResults contains results of the UsersRepository.GetExpirationDate
type UsersRepositoryMockGetExpirationDateResults struct {
	t1  time.Time
	err error
}

// UsersRepositoryMockGetExpirationDateOrigins contains origins of expectations of the UsersRepository.GetExpirationDate
type UsersRepositoryMockGetExpirationDateExpectationOrigins struct {
	origin        string
	originUserID  string
	originOrderID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetExpirationDate *mUsersRepositoryMockGetExpirationDate) Optional() *mUsersRepositoryMockGetExpirationDate {
	mmGetExpirationDate.optional = true
	return mmGetExpirationDate
}

// Expect sets up expected params for UsersRepository.GetExpirationDate
func (mmGetExpirationDate *mUsersRepositoryMockGetExpirationDate) Expect(userID uint64, orderID uint64) *mUsersRepositoryMockGetExpirationDate {
	if mmGetExpirationDate.mock.funcGetExpirationDate != nil {
		mmGetExpirationDate.mock.t.Fatalf("UsersRepositoryMock.GetExpirationDate mock is already set by Set")
	}

	if mmGetExpirationDate.defaultExpectation == nil {
		mmGetExpirationDate.defaultExpectation = &UsersRepositoryMockGetExpirationDateExpectation{}
	}

	if mmGetExpirationDate.defaultExpectation.paramPtrs != nil {
		mmGetExpirationDate.mock.t.Fatalf("UsersRepositoryMock.GetExpirationDate mock is already set by ExpectParams functions")
	}

	mmGetExpirationDate.defaultExpectation.params = &UsersRepositoryMockGetExpirationDateParams{userID, orderID}
	mmGetExpirationDate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetExpirationDate.expectations {
		if minimock.Equal(e.params, mmGetExpirationDate.defaultExpectation.params) {
			mmGetExpirationDate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetExpirationDate.defaultExpectation.params)
		}
	}

	return mmGetExpirationDate
}

// ExpectUserIDParam1 sets up expected param userID for UsersRepository.GetExpirationDate
func (mmGetExpirationDate *mUsersRepositoryMockGetExpirationDate) ExpectUserIDParam1(userID uint64) *mUsersRepositoryMockGetExpirationDate {
	if mmGetExpirationDate.mock.funcGetExpirationDate != nil {
		mmGetExpirationDate.mock.t.Fatalf("UsersRepositoryMock.GetExpirationDate mock is already set by Set")
	}

	if mmGetExpirationDate.defaultExpectation == nil {
		mmGetExpirationDate.defaultExpectation = &UsersRepositoryMockGetExpirationDateExpectation{}
	}

	if mmGetExpirationDate.defaultExpectation.params != nil {
		mmGetExpirationDate.mock.t.Fatalf("UsersRepositoryMock.GetExpirationDate mock is already set by Expect")
	}

	if mmGetExpirationDate.defaultExpectation.paramPtrs == nil {
		mmGetExpirationDate.defaultExpectation.paramPtrs = &UsersRepositoryMockGetExpirationDateParamPtrs{}
	}
	mmGetExpirationDate.defaultExpectation.paramPtrs.userID = &userID
	mmGetExpirationDate.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmGetExpirationDate
}

// ExpectOrderIDParam2 sets up expected param orderID for UsersRepository.GetExpirationDate
func (mmGetExpirationDate *mUsersRepositoryMockGetExpirationDate) ExpectOrderIDParam2(orderID uint64) *mUsersRepositoryMockGetExpirationDate {
	if mmGetExpirationDate.mock.funcGetExpirationDate != nil {
		mmGetExpirationDate.mock.t.Fatalf("UsersRepositoryMock.GetExpirationDate mock is already set by Set")
	}

	if mmGetExpirationDate.defaultExpectation == nil {
		mmGetExpirationDate.defaultExpectation = &UsersRepositoryMockGetExpirationDateExpectation{}
	}

	if mmGetExpirationDate.defaultExpectation.params != nil {
		mmGetExpirationDate.mock.t.Fatalf("UsersRepositoryMock.GetExpirationDate mock is already set by Expect")
	}

	if mmGetExpirationDate.defaultExpectation.paramPtrs == nil {
		mmGetExpirationDate.defaultExpectation.paramPtrs = &UsersRepositoryMockGetExpirationDateParamPtrs{}
	}
	mmGetExpirationDate.defaultExpectation.paramPtrs.orderID = &orderID
	mmGetExpirationDate.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmGetExpirationDate
}

// Inspect accepts an inspector function that has same arguments as the UsersRepository.GetExpirationDate
func (mmGetExpirationDate *mUsersRepositoryMockGetExpirationDate) Inspect(f func(userID uint64, orderID uint64)) *mUsersRepositoryMockGetExpirationDate {
	if mmGetExpirationDate.mock.inspectFuncGetExpirationDate != nil {
		mmGetExpirationDate.mock.t.Fatalf("Inspect function is already set for UsersRepositoryMock.GetExpirationDate")
	}

	mmGetExpirationDate.mock.inspectFuncGetExpirationDate = f

	return mmGetExpirationDate
}

// Return sets up results that will be returned by UsersRepository.GetExpirationDate
func (mmGetExpirationDate *mUsersRepositoryMockGetExpirationDate) Return(t1 time.Time, err error) *UsersRepositoryMock {
	if mmGetExpirationDate.mock.funcGetExpirationDate != nil {
		mmGetExpirationDate.mock.t.Fatalf("UsersRepositoryMock.GetExpirationDate mock is already set by Set")
	}

	if mmGetExpirationDate.defaultExpectation == nil {
		mmGetExpirationDate.defaultExpectation = &UsersRepositoryMockGetExpirationDateExpectation{mock: mmGetExpirationDate.mock}
	}
	mmGetExpirationDate.defaultExpectation.results = &UsersRepositoryMockGetExpirationDateResults{t1, err}
	mmGetExpirationDate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetExpirationDate.mock
}

// Set uses given function f to mock the UsersRepository.GetExpirationDate method
func (mmGetExpirationDate *mUsersRepositoryMockGetExpirationDate) Set(f func(userID uint64, orderID uint64) (t1 time.Time, err error)) *UsersRepositoryMock {
	if mmGetExpirationDate.defaultExpectation != nil {
		mmGetExpirationDate.mock.t.Fatalf("Default expectation is already set for the UsersRepository.GetExpirationDate method")
	}

	if len(mmGetExpirationDate.expectations) > 0 {
		mmGetExpirationDate.mock.t.Fatalf("Some expectations are already set for the UsersRepository.GetExpirationDate method")
	}

	mmGetExpirationDate.mock.funcGetExpirationDate = f
	mmGetExpirationDate.mock.funcGetExpirationDateOrigin = minimock.CallerInfo(1)
	return mmGetExpirationDate.mock
}

// When sets expectation for the UsersRepository.GetExpirationDate which will trigger the result defined by the following
// Then helper
func (mmGetExpirationDate *mUsersRepositoryMockGetExpirationDate) When(userID uint64, orderID uint64) *UsersRepositoryMockGetExpirationDateExpectation {
	if mmGetExpirationDate.mock.funcGetExpirationDate != nil {
		mmGetExpirationDate.mock.t.Fatalf("UsersRepositoryMock.GetExpirationDate mock is already set by Set")
	}

	expectation := &UsersRepositoryMockGetExpirationDateExpectation{
		mock:               mmGetExpirationDate.mock,
		params:             &UsersRepositoryMockGetExpirationDateParams{userID, orderID},
		expectationOrigins: UsersRepositoryMockGetExpirationDateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetExpirationDate.expectations = append(mmGetExpirationDate.expectations, expectation)
	return expectation
}

// Then sets up UsersRepository.GetExpirationDate return parameters for the expectation previously defined by the When method
func (e *UsersRepositoryMockGetExpirationDateExpectation) Then(t1 time.Time, err error) *UsersRepositoryMock {
	e.results = &UsersRepositoryMockGetExpirationDateResults{t1, err}
	return e.mock
}

// Times sets number of times UsersRepository.GetExpirationDate should be invoked
func (mmGetExpirationDate *mUsersRepositoryMockGetExpirationDate) Times(n uint64) *mUsersRepositoryMockGetExpirationDate {
	if n == 0 {
		mmGetExpirationDate.mock.t.Fatalf("Times of UsersRepositoryMock.GetExpirationDate mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetExpirationDate.expectedInvocations, n)
	mmGetExpirationDate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetExpirationDate
}

func (mmGetExpirationDate *mUsersRepositoryMockGetExpirationDate) invocationsDone() bool {
	if len(mmGetExpirationDate.expectations) == 0 && mmGetExpirationDate.defaultExpectation == nil && mmGetExpirationDate.mock.funcGetExpirationDate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetExpirationDate.mock.afterGetExpirationDateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetExpirationDate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetExpirationDate implements mm_storage.UsersRepository
func (mmGetExpirationDate *UsersRepositoryMock) GetExpirationDate(userID uint64, orderID uint64) (t1 time.Time, err error) {
	mm_atomic.AddUint64(&mmGetExpirationDate.beforeGetExpirationDateCounter, 1)
	defer mm_atomic.AddUint64(&mmGetExpirationDate.afterGetExpirationDateCounter, 1)

	mmGetExpirationDate.t.Helper()

	if mmGetExpirationDate.inspectFuncGetExpirationDate != nil {
		mmGetExpirationDate.inspectFuncGetExpirationDate(userID, orderID)
	}

	mm_params := UsersRepositoryMockGetExpirationDateParams{userID, orderID}

	// Record call args
	mmGetExpirationDate.GetExpirationDateMock.mutex.Lock()
	mmGetExpirationDate.GetExpirationDateMock.callArgs = append(mmGetExpirationDate.GetExpirationDateMock.callArgs, &mm_params)
	mmGetExpirationDate.GetExpirationDateMock.mutex.Unlock()

	for _, e := range mmGetExpirationDate.GetExpirationDateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.t1, e.results.err
		}
	}

	if mmGetExpirationDate.GetExpirationDateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetExpirationDate.GetExpirationDateMock.defaultExpectation.Counter, 1)
		mm_want := mmGetExpirationDate.GetExpirationDateMock.defaultExpectation.params
		mm_want_ptrs := mmGetExpirationDate.GetExpirationDateMock.defaultExpectation.paramPtrs

		mm_got := UsersRepositoryMockGetExpirationDateParams{userID, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetExpirationDate.t.Errorf("UsersRepositoryMock.GetExpirationDate got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetExpirationDate.GetExpirationDateMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmGetExpirationDate.t.Errorf("UsersRepositoryMock.GetExpirationDate got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetExpirationDate.GetExpirationDateMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetExpirationDate.t.Errorf("UsersRepositoryMock.GetExpirationDate got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetExpirationDate.GetExpirationDateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetExpirationDate.GetExpirationDateMock.defaultExpectation.results
		if mm_results == nil {
			mmGetExpirationDate.t.Fatal("No results are set for the UsersRepositoryMock.GetExpirationDate")
		}
		return (*mm_results).t1, (*mm_results).err
	}
	if mmGetExpirationDate.funcGetExpirationDate != nil {
		return mmGetExpirationDate.funcGetExpirationDate(userID, orderID)
	}
	mmGetExpirationDate.t.Fatalf("Unexpected call to UsersRepositoryMock.GetExpirationDate. %v %v", userID, orderID)
	return
}

// GetExpirationDateAfterCounter returns a count of finished UsersRepositoryMock.GetExpirationDate invocations
func (mmGetExpirationDate *UsersRepositoryMock) GetExpirationDateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetExpirationDate.afterGetExpirationDateCounter)
}

// GetExpirationDateBeforeCounter returns a count of UsersRepositoryMock.GetExpirationDate invocations
func (mmGetExpirationDate *UsersRepositoryMock) GetExpirationDateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetExpirationDate.beforeGetExpirationDateCounter)
}

// Calls returns a list of arguments used in each call to UsersRepositoryMock.GetExpirationDate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetExpirationDate *mUsersRepositoryMockGetExpirationDate) Calls() []*UsersRepositoryMockGetExpirationDateParams {
	mmGetExpirationDate.mutex.RLock()

	argCopy := make([]*UsersRepositoryMockGetExpirationDateParams, len(mmGetExpirationDate.callArgs))
	copy(argCopy, mmGetExpirationDate.callArgs)

	mmGetExpirationDate.mutex.RUnlock()

	return argCopy
}

// MinimockGetExpirationDateDone returns true if the count of the GetExpirationDate invocations corresponds
// the number of defined expectations
func (m *UsersRepositoryMock) MinimockGetExpirationDateDone() bool {
	if m.GetExpirationDateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetExpirationDateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetExpirationDateMock.invocationsDone()
}

// MinimockGetExpirationDateInspect logs each unmet expectation
func (m *UsersRepositoryMock) MinimockGetExpirationDateInspect() {
	for _, e := range m.GetExpirationDateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UsersRepositoryMock.GetExpirationDate at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetExpirationDateCounter := mm_atomic.LoadUint64(&m.afterGetExpirationDateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetExpirationDateMock.defaultExpectation != nil && afterGetExpirationDateCounter < 1 {
		if m.GetExpirationDateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UsersRepositoryMock.GetExpirationDate at\n%s", m.GetExpirationDateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UsersRepositoryMock.GetExpirationDate at\n%s with params: %#v", m.GetExpirationDateMock.defaultExpectation.expectationOrigins.origin, *m.GetExpirationDateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetExpirationDate != nil && afterGetExpirationDateCounter < 1 {
		m.t.Errorf("Expected call to UsersRepositoryMock.GetExpirationDate at\n%s", m.funcGetExpirationDateOrigin)
	}

	if !m.GetExpirationDateMock.invocationsDone() && afterGetExpirationDateCounter > 0 {
		m.t.Errorf("Expected %d calls to UsersRepositoryMock.GetExpirationDate at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetExpirationDateMock.expectedInvocations), m.GetExpirationDateMock.expectedInvocationsOrigin, afterGetExpirationDateCounter)
	}
}

type mUsersRepositoryMockGetOrder struct {
	optional           bool
	mock               *UsersRepositoryMock
	defaultExpectation *UsersRepositoryMockGetOrderExpectation
	expectations       []*UsersRepositoryMockGetOrderExpectation

	callArgs []*UsersRepositoryMockGetOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UsersRepositoryMockGetOrderExpectation specifies expectation struct of the UsersRepository.GetOrder
type UsersRepositoryMockGetOrderExpectation struct {
	mock               *UsersRepositoryMock
	params             *UsersRepositoryMockGetOrderParams
	paramPtrs          *UsersRepositoryMockGetOrderParamPtrs
	expectationOrigins UsersRepositoryMockGetOrderExpectationOrigins
	results            *UsersRepositoryMockGetOrderResults
	returnOrigin       string
	Counter            uint64
}

// UsersRepositoryMockGetOrderParams contains parameters of the UsersRepository.GetOrder
type UsersRepositoryMockGetOrderParams struct {
	userID  uint64
	orderID uint64
}

// UsersRepositoryMockGetOrderParamPtrs contains pointers to parameters of the UsersRepository.GetOrder
type UsersRepositoryMockGetOrderParamPtrs struct {
	userID  *uint64
	orderID *uint64
}

// UsersRepositoryMockGetOrderResults contains results of the UsersRepository.GetOrder
type UsersRepositoryMockGetOrderResults struct {
	op1 *domain.Order
	err error
}

// UsersRepositoryMockGetOrderOrigins contains origins of expectations of the UsersRepository.GetOrder
type UsersRepositoryMockGetOrderExpectationOrigins struct {
	origin        string
	originUserID  string
	originOrderID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrder *mUsersRepositoryMockGetOrder) Optional() *mUsersRepositoryMockGetOrder {
	mmGetOrder.optional = true
	return mmGetOrder
}

// Expect sets up expected params for UsersRepository.GetOrder
func (mmGetOrder *mUsersRepositoryMockGetOrder) Expect(userID uint64, orderID uint64) *mUsersRepositoryMockGetOrder {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("UsersRepositoryMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &UsersRepositoryMockGetOrderExpectation{}
	}

	if mmGetOrder.defaultExpectation.paramPtrs != nil {
		mmGetOrder.mock.t.Fatalf("UsersRepositoryMock.GetOrder mock is already set by ExpectParams functions")
	}

	mmGetOrder.defaultExpectation.params = &UsersRepositoryMockGetOrderParams{userID, orderID}
	mmGetOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetOrder.expectations {
		if minimock.Equal(e.params, mmGetOrder.defaultExpectation.params) {
			mmGetOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrder.defaultExpectation.params)
		}
	}

	return mmGetOrder
}

// ExpectUserIDParam1 sets up expected param userID for UsersRepository.GetOrder
func (mmGetOrder *mUsersRepositoryMockGetOrder) ExpectUserIDParam1(userID uint64) *mUsersRepositoryMockGetOrder {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("UsersRepositoryMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &UsersRepositoryMockGetOrderExpectation{}
	}

	if mmGetOrder.defaultExpectation.params != nil {
		mmGetOrder.mock.t.Fatalf("UsersRepositoryMock.GetOrder mock is already set by Expect")
	}

	if mmGetOrder.defaultExpectation.paramPtrs == nil {
		mmGetOrder.defaultExpectation.paramPtrs = &UsersRepositoryMockGetOrderParamPtrs{}
	}
	mmGetOrder.defaultExpectation.paramPtrs.userID = &userID
	mmGetOrder.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmGetOrder
}

// ExpectOrderIDParam2 sets up expected param orderID for UsersRepository.GetOrder
func (mmGetOrder *mUsersRepositoryMockGetOrder) ExpectOrderIDParam2(orderID uint64) *mUsersRepositoryMockGetOrder {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("UsersRepositoryMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &UsersRepositoryMockGetOrderExpectation{}
	}

	if mmGetOrder.defaultExpectation.params != nil {
		mmGetOrder.mock.t.Fatalf("UsersRepositoryMock.GetOrder mock is already set by Expect")
	}

	if mmGetOrder.defaultExpectation.paramPtrs == nil {
		mmGetOrder.defaultExpectation.paramPtrs = &UsersRepositoryMockGetOrderParamPtrs{}
	}
	mmGetOrder.defaultExpectation.paramPtrs.orderID = &orderID
	mmGetOrder.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmGetOrder
}

// Inspect accepts an inspector function that has same arguments as the UsersRepository.GetOrder
func (mmGetOrder *mUsersRepositoryMockGetOrder) Inspect(f func(userID uint64, orderID uint64)) *mUsersRepositoryMockGetOrder {
	if mmGetOrder.mock.inspectFuncGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("Inspect function is already set for UsersRepositoryMock.GetOrder")
	}

	mmGetOrder.mock.inspectFuncGetOrder = f

	return mmGetOrder
}

// Return sets up results that will be returned by UsersRepository.GetOrder
func (mmGetOrder *mUsersRepositoryMockGetOrder) Return(op1 *domain.Order, err error) *UsersRepositoryMock {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("UsersRepositoryMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &UsersRepositoryMockGetOrderExpectation{mock: mmGetOrder.mock}
	}
	mmGetOrder.defaultExpectation.results = &UsersRepositoryMockGetOrderResults{op1, err}
	mmGetOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOrder.mock
}

// Set uses given function f to mock the UsersRepository.GetOrder method
func (mmGetOrder *mUsersRepositoryMockGetOrder) Set(f func(userID uint64, orderID uint64) (op1 *domain.Order, err error)) *UsersRepositoryMock {
	if mmGetOrder.defaultExpectation != nil {
		mmGetOrder.mock.t.Fatalf("Default expectation is already set for the UsersRepository.GetOrder method")
	}

	if len(mmGetOrder.expectations) > 0 {
		mmGetOrder.mock.t.Fatalf("Some expectations are already set for the UsersRepository.GetOrder method")
	}

	mmGetOrder.mock.funcGetOrder = f
	mmGetOrder.mock.funcGetOrderOrigin = minimock.CallerInfo(1)
	return mmGetOrder.mock
}

// When sets expectation for the UsersRepository.GetOrder which will trigger the result defined by the following
// Then helper
func (mmGetOrder *mUsersRepositoryMockGetOrder) When(userID uint64, orderID uint64) *UsersRepositoryMockGetOrderExpectation {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("UsersRepositoryMock.GetOrder mock is already set by Set")
	}

	expectation := &UsersRepositoryMockGetOrderExpectation{
		mock:               mmGetOrder.mock,
		params:             &UsersRepositoryMockGetOrderParams{userID, orderID},
		expectationOrigins: UsersRepositoryMockGetOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetOrder.expectations = append(mmGetOrder.expectations, expectation)
	return expectation
}

// Then sets up UsersRepository.GetOrder return parameters for the expectation previously defined by the When method
func (e *UsersRepositoryMockGetOrderExpectation) Then(op1 *domain.Order, err error) *UsersRepositoryMock {
	e.results = &UsersRepositoryMockGetOrderResults{op1, err}
	return e.mock
}

// Times sets number of times UsersRepository.GetOrder should be invoked
func (mmGetOrder *mUsersRepositoryMockGetOrder) Times(n uint64) *mUsersRepositoryMockGetOrder {
	if n == 0 {
		mmGetOrder.mock.t.Fatalf("Times of UsersRepositoryMock.GetOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrder.expectedInvocations, n)
	mmGetOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOrder
}

func (mmGetOrder *mUsersRepositoryMockGetOrder) invocationsDone() bool {
	if len(mmGetOrder.expectations) == 0 && mmGetOrder.defaultExpectation == nil && mmGetOrder.mock.funcGetOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrder.mock.afterGetOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrder implements mm_storage.UsersRepository
func (mmGetOrder *UsersRepositoryMock) GetOrder(userID uint64, orderID uint64) (op1 *domain.Order, err error) {
	mm_atomic.AddUint64(&mmGetOrder.beforeGetOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrder.afterGetOrderCounter, 1)

	mmGetOrder.t.Helper()

	if mmGetOrder.inspectFuncGetOrder != nil {
		mmGetOrder.inspectFuncGetOrder(userID, orderID)
	}

	mm_params := UsersRepositoryMockGetOrderParams{userID, orderID}

	// Record call args
	mmGetOrder.GetOrderMock.mutex.Lock()
	mmGetOrder.GetOrderMock.callArgs = append(mmGetOrder.GetOrderMock.callArgs, &mm_params)
	mmGetOrder.GetOrderMock.mutex.Unlock()

	for _, e := range mmGetOrder.GetOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetOrder.GetOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrder.GetOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrder.GetOrderMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrder.GetOrderMock.defaultExpectation.paramPtrs

		mm_got := UsersRepositoryMockGetOrderParams{userID, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetOrder.t.Errorf("UsersRepositoryMock.GetOrder got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrder.GetOrderMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmGetOrder.t.Errorf("UsersRepositoryMock.GetOrder got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrder.GetOrderMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrder.t.Errorf("UsersRepositoryMock.GetOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetOrder.GetOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrder.GetOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrder.t.Fatal("No results are set for the UsersRepositoryMock.GetOrder")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetOrder.funcGetOrder != nil {
		return mmGetOrder.funcGetOrder(userID, orderID)
	}
	mmGetOrder.t.Fatalf("Unexpected call to UsersRepositoryMock.GetOrder. %v %v", userID, orderID)
	return
}

// GetOrderAfterCounter returns a count of finished UsersRepositoryMock.GetOrder invocations
func (mmGetOrder *UsersRepositoryMock) GetOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrder.afterGetOrderCounter)
}

// GetOrderBeforeCounter returns a count of UsersRepositoryMock.GetOrder invocations
func (mmGetOrder *UsersRepositoryMock) GetOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrder.beforeGetOrderCounter)
}

// Calls returns a list of arguments used in each call to UsersRepositoryMock.GetOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrder *mUsersRepositoryMockGetOrder) Calls() []*UsersRepositoryMockGetOrderParams {
	mmGetOrder.mutex.RLock()

	argCopy := make([]*UsersRepositoryMockGetOrderParams, len(mmGetOrder.callArgs))
	copy(argCopy, mmGetOrder.callArgs)

	mmGetOrder.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrderDone returns true if the count of the GetOrder invocations corresponds
// the number of defined expectations
func (m *UsersRepositoryMock) MinimockGetOrderDone() bool {
	if m.GetOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrderMock.invocationsDone()
}

// MinimockGetOrderInspect logs each unmet expectation
func (m *UsersRepositoryMock) MinimockGetOrderInspect() {
	for _, e := range m.GetOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UsersRepositoryMock.GetOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetOrderCounter := mm_atomic.LoadUint64(&m.afterGetOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderMock.defaultExpectation != nil && afterGetOrderCounter < 1 {
		if m.GetOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UsersRepositoryMock.GetOrder at\n%s", m.GetOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UsersRepositoryMock.GetOrder at\n%s with params: %#v", m.GetOrderMock.defaultExpectation.expectationOrigins.origin, *m.GetOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrder != nil && afterGetOrderCounter < 1 {
		m.t.Errorf("Expected call to UsersRepositoryMock.GetOrder at\n%s", m.funcGetOrderOrigin)
	}

	if !m.GetOrderMock.invocationsDone() && afterGetOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to UsersRepositoryMock.GetOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrderMock.expectedInvocations), m.GetOrderMock.expectedInvocationsOrigin, afterGetOrderCounter)
	}
}

type mUsersRepositoryMockGetOrders struct {
	optional           bool
	mock               *UsersRepositoryMock
	defaultExpectation *UsersRepositoryMockGetOrdersExpectation
	expectations       []*UsersRepositoryMockGetOrdersExpectation

	callArgs []*UsersRepositoryMockGetOrdersParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UsersRepositoryMockGetOrdersExpectation specifies expectation struct of the UsersRepository.GetOrders
type UsersRepositoryMockGetOrdersExpectation struct {
	mock               *UsersRepositoryMock
	params             *UsersRepositoryMockGetOrdersParams
	paramPtrs          *UsersRepositoryMockGetOrdersParamPtrs
	expectationOrigins UsersRepositoryMockGetOrdersExpectationOrigins
	results            *UsersRepositoryMockGetOrdersResults
	returnOrigin       string
	Counter            uint64
}

// UsersRepositoryMockGetOrdersParams contains parameters of the UsersRepository.GetOrders
type UsersRepositoryMockGetOrdersParams struct {
	userID       uint64
	firstOrderID uint64
	limit        uint64
}

// UsersRepositoryMockGetOrdersParamPtrs contains pointers to parameters of the UsersRepository.GetOrders
type UsersRepositoryMockGetOrdersParamPtrs struct {
	userID       *uint64
	firstOrderID *uint64
	limit        *uint64
}

// UsersRepositoryMockGetOrdersResults contains results of the UsersRepository.GetOrders
type UsersRepositoryMockGetOrdersResults struct {
	oa1 []domain.OrderView
	err error
}

// UsersRepositoryMockGetOrdersOrigins contains origins of expectations of the UsersRepository.GetOrders
type UsersRepositoryMockGetOrdersExpectationOrigins struct {
	origin             string
	originUserID       string
	originFirstOrderID string
	originLimit        string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrders *mUsersRepositoryMockGetOrders) Optional() *mUsersRepositoryMockGetOrders {
	mmGetOrders.optional = true
	return mmGetOrders
}

// Expect sets up expected params for UsersRepository.GetOrders
func (mmGetOrders *mUsersRepositoryMockGetOrders) Expect(userID uint64, firstOrderID uint64, limit uint64) *mUsersRepositoryMockGetOrders {
	if mmGetOrders.mock.funcGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("UsersRepositoryMock.GetOrders mock is already set by Set")
	}

	if mmGetOrders.defaultExpectation == nil {
		mmGetOrders.defaultExpectation = &UsersRepositoryMockGetOrdersExpectation{}
	}

	if mmGetOrders.defaultExpectation.paramPtrs != nil {
		mmGetOrders.mock.t.Fatalf("UsersRepositoryMock.GetOrders mock is already set by ExpectParams functions")
	}

	mmGetOrders.defaultExpectation.params = &UsersRepositoryMockGetOrdersParams{userID, firstOrderID, limit}
	mmGetOrders.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetOrders.expectations {
		if minimock.Equal(e.params, mmGetOrders.defaultExpectation.params) {
			mmGetOrders.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrders.defaultExpectation.params)
		}
	}

	return mmGetOrders
}

// ExpectUserIDParam1 sets up expected param userID for UsersRepository.GetOrders
func (mmGetOrders *mUsersRepositoryMockGetOrders) ExpectUserIDParam1(userID uint64) *mUsersRepositoryMockGetOrders {
	if mmGetOrders.mock.funcGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("UsersRepositoryMock.GetOrders mock is already set by Set")
	}

	if mmGetOrders.defaultExpectation == nil {
		mmGetOrders.defaultExpectation = &UsersRepositoryMockGetOrdersExpectation{}
	}

	if mmGetOrders.defaultExpectation.params != nil {
		mmGetOrders.mock.t.Fatalf("UsersRepositoryMock.GetOrders mock is already set by Expect")
	}

	if mmGetOrders.defaultExpectation.paramPtrs == nil {
		mmGetOrders.defaultExpectation.paramPtrs = &UsersRepositoryMockGetOrdersParamPtrs{}
	}
	mmGetOrders.defaultExpectation.paramPtrs.userID = &userID
	mmGetOrders.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmGetOrders
}

// ExpectFirstOrderIDParam2 sets up expected param firstOrderID for UsersRepository.GetOrders
func (mmGetOrders *mUsersRepositoryMockGetOrders) ExpectFirstOrderIDParam2(firstOrderID uint64) *mUsersRepositoryMockGetOrders {
	if mmGetOrders.mock.funcGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("UsersRepositoryMock.GetOrders mock is already set by Set")
	}

	if mmGetOrders.defaultExpectation == nil {
		mmGetOrders.defaultExpectation = &UsersRepositoryMockGetOrdersExpectation{}
	}

	if mmGetOrders.defaultExpectation.params != nil {
		mmGetOrders.mock.t.Fatalf("UsersRepositoryMock.GetOrders mock is already set by Expect")
	}

	if mmGetOrders.defaultExpectation.paramPtrs == nil {
		mmGetOrders.defaultExpectation.paramPtrs = &UsersRepositoryMockGetOrdersParamPtrs{}
	}
	mmGetOrders.defaultExpectation.paramPtrs.firstOrderID = &firstOrderID
	mmGetOrders.defaultExpectation.expectationOrigins.originFirstOrderID = minimock.CallerInfo(1)

	return mmGetOrders
}

// ExpectLimitParam3 sets up expected param limit for UsersRepository.GetOrders
func (mmGetOrders *mUsersRepositoryMockGetOrders) ExpectLimitParam3(limit uint64) *mUsersRepositoryMockGetOrders {
	if mmGetOrders.mock.funcGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("UsersRepositoryMock.GetOrders mock is already set by Set")
	}

	if mmGetOrders.defaultExpectation == nil {
		mmGetOrders.defaultExpectation = &UsersRepositoryMockGetOrdersExpectation{}
	}

	if mmGetOrders.defaultExpectation.params != nil {
		mmGetOrders.mock.t.Fatalf("UsersRepositoryMock.GetOrders mock is already set by Expect")
	}

	if mmGetOrders.defaultExpectation.paramPtrs == nil {
		mmGetOrders.defaultExpectation.paramPtrs = &UsersRepositoryMockGetOrdersParamPtrs{}
	}
	mmGetOrders.defaultExpectation.paramPtrs.limit = &limit
	mmGetOrders.defaultExpectation.expectationOrigins.originLimit = minimock.CallerInfo(1)

	return mmGetOrders
}

// Inspect accepts an inspector function that has same arguments as the UsersRepository.GetOrders
func (mmGetOrders *mUsersRepositoryMockGetOrders) Inspect(f func(userID uint64, firstOrderID uint64, limit uint64)) *mUsersRepositoryMockGetOrders {
	if mmGetOrders.mock.inspectFuncGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("Inspect function is already set for UsersRepositoryMock.GetOrders")
	}

	mmGetOrders.mock.inspectFuncGetOrders = f

	return mmGetOrders
}

// Return sets up results that will be returned by UsersRepository.GetOrders
func (mmGetOrders *mUsersRepositoryMockGetOrders) Return(oa1 []domain.OrderView, err error) *UsersRepositoryMock {
	if mmGetOrders.mock.funcGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("UsersRepositoryMock.GetOrders mock is already set by Set")
	}

	if mmGetOrders.defaultExpectation == nil {
		mmGetOrders.defaultExpectation = &UsersRepositoryMockGetOrdersExpectation{mock: mmGetOrders.mock}
	}
	mmGetOrders.defaultExpectation.results = &UsersRepositoryMockGetOrdersResults{oa1, err}
	mmGetOrders.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOrders.mock
}

// Set uses given function f to mock the UsersRepository.GetOrders method
func (mmGetOrders *mUsersRepositoryMockGetOrders) Set(f func(userID uint64, firstOrderID uint64, limit uint64) (oa1 []domain.OrderView, err error)) *UsersRepositoryMock {
	if mmGetOrders.defaultExpectation != nil {
		mmGetOrders.mock.t.Fatalf("Default expectation is already set for the UsersRepository.GetOrders method")
	}

	if len(mmGetOrders.expectations) > 0 {
		mmGetOrders.mock.t.Fatalf("Some expectations are already set for the UsersRepository.GetOrders method")
	}

	mmGetOrders.mock.funcGetOrders = f
	mmGetOrders.mock.funcGetOrdersOrigin = minimock.CallerInfo(1)
	return mmGetOrders.mock
}

// When sets expectation for the UsersRepository.GetOrders which will trigger the result defined by the following
// Then helper
func (mmGetOrders *mUsersRepositoryMockGetOrders) When(userID uint64, firstOrderID uint64, limit uint64) *UsersRepositoryMockGetOrdersExpectation {
	if mmGetOrders.mock.funcGetOrders != nil {
		mmGetOrders.mock.t.Fatalf("UsersRepositoryMock.GetOrders mock is already set by Set")
	}

	expectation := &UsersRepositoryMockGetOrdersExpectation{
		mock:               mmGetOrders.mock,
		params:             &UsersRepositoryMockGetOrdersParams{userID, firstOrderID, limit},
		expectationOrigins: UsersRepositoryMockGetOrdersExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetOrders.expectations = append(mmGetOrders.expectations, expectation)
	return expectation
}

// Then sets up UsersRepository.GetOrders return parameters for the expectation previously defined by the When method
func (e *UsersRepositoryMockGetOrdersExpectation) Then(oa1 []domain.OrderView, err error) *UsersRepositoryMock {
	e.results = &UsersRepositoryMockGetOrdersResults{oa1, err}
	return e.mock
}

// Times sets number of times UsersRepository.GetOrders should be invoked
func (mmGetOrders *mUsersRepositoryMockGetOrders) Times(n uint64) *mUsersRepositoryMockGetOrders {
	if n == 0 {
		mmGetOrders.mock.t.Fatalf("Times of UsersRepositoryMock.GetOrders mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrders.expectedInvocations, n)
	mmGetOrders.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOrders
}

func (mmGetOrders *mUsersRepositoryMockGetOrders) invocationsDone() bool {
	if len(mmGetOrders.expectations) == 0 && mmGetOrders.defaultExpectation == nil && mmGetOrders.mock.funcGetOrders == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrders.mock.afterGetOrdersCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrders.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrders implements mm_storage.UsersRepository
func (mmGetOrders *UsersRepositoryMock) GetOrders(userID uint64, firstOrderID uint64, limit uint64) (oa1 []domain.OrderView, err error) {
	mm_atomic.AddUint64(&mmGetOrders.beforeGetOrdersCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrders.afterGetOrdersCounter, 1)

	mmGetOrders.t.Helper()

	if mmGetOrders.inspectFuncGetOrders != nil {
		mmGetOrders.inspectFuncGetOrders(userID, firstOrderID, limit)
	}

	mm_params := UsersRepositoryMockGetOrdersParams{userID, firstOrderID, limit}

	// Record call args
	mmGetOrders.GetOrdersMock.mutex.Lock()
	mmGetOrders.GetOrdersMock.callArgs = append(mmGetOrders.GetOrdersMock.callArgs, &mm_params)
	mmGetOrders.GetOrdersMock.mutex.Unlock()

	for _, e := range mmGetOrders.GetOrdersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.err
		}
	}

	if mmGetOrders.GetOrdersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrders.GetOrdersMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrders.GetOrdersMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrders.GetOrdersMock.defaultExpectation.paramPtrs

		mm_got := UsersRepositoryMockGetOrdersParams{userID, firstOrderID, limit}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetOrders.t.Errorf("UsersRepositoryMock.GetOrders got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrders.GetOrdersMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.firstOrderID != nil && !minimock.Equal(*mm_want_ptrs.firstOrderID, mm_got.firstOrderID) {
				mmGetOrders.t.Errorf("UsersRepositoryMock.GetOrders got unexpected parameter firstOrderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrders.GetOrdersMock.defaultExpectation.expectationOrigins.originFirstOrderID, *mm_want_ptrs.firstOrderID, mm_got.firstOrderID, minimock.Diff(*mm_want_ptrs.firstOrderID, mm_got.firstOrderID))
			}

			if mm_want_ptrs.limit != nil && !minimock.Equal(*mm_want_ptrs.limit, mm_got.limit) {
				mmGetOrders.t.Errorf("UsersRepositoryMock.GetOrders got unexpected parameter limit, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrders.GetOrdersMock.defaultExpectation.expectationOrigins.originLimit, *mm_want_ptrs.limit, mm_got.limit, minimock.Diff(*mm_want_ptrs.limit, mm_got.limit))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrders.t.Errorf("UsersRepositoryMock.GetOrders got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetOrders.GetOrdersMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrders.GetOrdersMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrders.t.Fatal("No results are set for the UsersRepositoryMock.GetOrders")
		}
		return (*mm_results).oa1, (*mm_results).err
	}
	if mmGetOrders.funcGetOrders != nil {
		return mmGetOrders.funcGetOrders(userID, firstOrderID, limit)
	}
	mmGetOrders.t.Fatalf("Unexpected call to UsersRepositoryMock.GetOrders. %v %v %v", userID, firstOrderID, limit)
	return
}

// GetOrdersAfterCounter returns a count of finished UsersRepositoryMock.GetOrders invocations
func (mmGetOrders *UsersRepositoryMock) GetOrdersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrders.afterGetOrdersCounter)
}

// GetOrdersBeforeCounter returns a count of UsersRepositoryMock.GetOrders invocations
func (mmGetOrders *UsersRepositoryMock) GetOrdersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrders.beforeGetOrdersCounter)
}

// Calls returns a list of arguments used in each call to UsersRepositoryMock.GetOrders.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrders *mUsersRepositoryMockGetOrders) Calls() []*UsersRepositoryMockGetOrdersParams {
	mmGetOrders.mutex.RLock()

	argCopy := make([]*UsersRepositoryMockGetOrdersParams, len(mmGetOrders.callArgs))
	copy(argCopy, mmGetOrders.callArgs)

	mmGetOrders.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrdersDone returns true if the count of the GetOrders invocations corresponds
// the number of defined expectations
func (m *UsersRepositoryMock) MinimockGetOrdersDone() bool {
	if m.GetOrdersMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrdersMock.invocationsDone()
}

// MinimockGetOrdersInspect logs each unmet expectation
func (m *UsersRepositoryMock) MinimockGetOrdersInspect() {
	for _, e := range m.GetOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UsersRepositoryMock.GetOrders at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetOrdersCounter := mm_atomic.LoadUint64(&m.afterGetOrdersCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrdersMock.defaultExpectation != nil && afterGetOrdersCounter < 1 {
		if m.GetOrdersMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UsersRepositoryMock.GetOrders at\n%s", m.GetOrdersMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UsersRepositoryMock.GetOrders at\n%s with params: %#v", m.GetOrdersMock.defaultExpectation.expectationOrigins.origin, *m.GetOrdersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrders != nil && afterGetOrdersCounter < 1 {
		m.t.Errorf("Expected call to UsersRepositoryMock.GetOrders at\n%s", m.funcGetOrdersOrigin)
	}

	if !m.GetOrdersMock.invocationsDone() && afterGetOrdersCounter > 0 {
		m.t.Errorf("Expected %d calls to UsersRepositoryMock.GetOrders at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrdersMock.expectedInvocations), m.GetOrdersMock.expectedInvocationsOrigin, afterGetOrdersCounter)
	}
}

type mUsersRepositoryMockRemoveOrder struct {
	optional           bool
	mock               *UsersRepositoryMock
	defaultExpectation *UsersRepositoryMockRemoveOrderExpectation
	expectations       []*UsersRepositoryMockRemoveOrderExpectation

	callArgs []*UsersRepositoryMockRemoveOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UsersRepositoryMockRemoveOrderExpectation specifies expectation struct of the UsersRepository.RemoveOrder
type UsersRepositoryMockRemoveOrderExpectation struct {
	mock               *UsersRepositoryMock
	params             *UsersRepositoryMockRemoveOrderParams
	paramPtrs          *UsersRepositoryMockRemoveOrderParamPtrs
	expectationOrigins UsersRepositoryMockRemoveOrderExpectationOrigins
	results            *UsersRepositoryMockRemoveOrderResults
	returnOrigin       string
	Counter            uint64
}

// UsersRepositoryMockRemoveOrderParams contains parameters of the UsersRepository.RemoveOrder
type UsersRepositoryMockRemoveOrderParams struct {
	userID  uint64
	orderID uint64
}

// UsersRepositoryMockRemoveOrderParamPtrs contains pointers to parameters of the UsersRepository.RemoveOrder
type UsersRepositoryMockRemoveOrderParamPtrs struct {
	userID  *uint64
	orderID *uint64
}

// UsersRepositoryMockRemoveOrderResults contains results of the UsersRepository.RemoveOrder
type UsersRepositoryMockRemoveOrderResults struct {
	err error
}

// UsersRepositoryMockRemoveOrderOrigins contains origins of expectations of the UsersRepository.RemoveOrder
type UsersRepositoryMockRemoveOrderExpectationOrigins struct {
	origin        string
	originUserID  string
	originOrderID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemoveOrder *mUsersRepositoryMockRemoveOrder) Optional() *mUsersRepositoryMockRemoveOrder {
	mmRemoveOrder.optional = true
	return mmRemoveOrder
}

// Expect sets up expected params for UsersRepository.RemoveOrder
func (mmRemoveOrder *mUsersRepositoryMockRemoveOrder) Expect(userID uint64, orderID uint64) *mUsersRepositoryMockRemoveOrder {
	if mmRemoveOrder.mock.funcRemoveOrder != nil {
		mmRemoveOrder.mock.t.Fatalf("UsersRepositoryMock.RemoveOrder mock is already set by Set")
	}

	if mmRemoveOrder.defaultExpectation == nil {
		mmRemoveOrder.defaultExpectation = &UsersRepositoryMockRemoveOrderExpectation{}
	}

	if mmRemoveOrder.defaultExpectation.paramPtrs != nil {
		mmRemoveOrder.mock.t.Fatalf("UsersRepositoryMock.RemoveOrder mock is already set by ExpectParams functions")
	}

	mmRemoveOrder.defaultExpectation.params = &UsersRepositoryMockRemoveOrderParams{userID, orderID}
	mmRemoveOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRemoveOrder.expectations {
		if minimock.Equal(e.params, mmRemoveOrder.defaultExpectation.params) {
			mmRemoveOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveOrder.defaultExpectation.params)
		}
	}

	return mmRemoveOrder
}

// ExpectUserIDParam1 sets up expected param userID for UsersRepository.RemoveOrder
func (mmRemoveOrder *mUsersRepositoryMockRemoveOrder) ExpectUserIDParam1(userID uint64) *mUsersRepositoryMockRemoveOrder {
	if mmRemoveOrder.mock.funcRemoveOrder != nil {
		mmRemoveOrder.mock.t.Fatalf("UsersRepositoryMock.RemoveOrder mock is already set by Set")
	}

	if mmRemoveOrder.defaultExpectation == nil {
		mmRemoveOrder.defaultExpectation = &UsersRepositoryMockRemoveOrderExpectation{}
	}

	if mmRemoveOrder.defaultExpectation.params != nil {
		mmRemoveOrder.mock.t.Fatalf("UsersRepositoryMock.RemoveOrder mock is already set by Expect")
	}

	if mmRemoveOrder.defaultExpectation.paramPtrs == nil {
		mmRemoveOrder.defaultExpectation.paramPtrs = &UsersRepositoryMockRemoveOrderParamPtrs{}
	}
	mmRemoveOrder.defaultExpectation.paramPtrs.userID = &userID
	mmRemoveOrder.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmRemoveOrder
}

// ExpectOrderIDParam2 sets up expected param orderID for UsersRepository.RemoveOrder
func (mmRemoveOrder *mUsersRepositoryMockRemoveOrder) ExpectOrderIDParam2(orderID uint64) *mUsersRepositoryMockRemoveOrder {
	if mmRemoveOrder.mock.funcRemoveOrder != nil {
		mmRemoveOrder.mock.t.Fatalf("UsersRepositoryMock.RemoveOrder mock is already set by Set")
	}

	if mmRemoveOrder.defaultExpectation == nil {
		mmRemoveOrder.defaultExpectation = &UsersRepositoryMockRemoveOrderExpectation{}
	}

	if mmRemoveOrder.defaultExpectation.params != nil {
		mmRemoveOrder.mock.t.Fatalf("UsersRepositoryMock.RemoveOrder mock is already set by Expect")
	}

	if mmRemoveOrder.defaultExpectation.paramPtrs == nil {
		mmRemoveOrder.defaultExpectation.paramPtrs = &UsersRepositoryMockRemoveOrderParamPtrs{}
	}
	mmRemoveOrder.defaultExpectation.paramPtrs.orderID = &orderID
	mmRemoveOrder.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmRemoveOrder
}

// Inspect accepts an inspector function that has same arguments as the UsersRepository.RemoveOrder
func (mmRemoveOrder *mUsersRepositoryMockRemoveOrder) Inspect(f func(userID uint64, orderID uint64)) *mUsersRepositoryMockRemoveOrder {
	if mmRemoveOrder.mock.inspectFuncRemoveOrder != nil {
		mmRemoveOrder.mock.t.Fatalf("Inspect function is already set for UsersRepositoryMock.RemoveOrder")
	}

	mmRemoveOrder.mock.inspectFuncRemoveOrder = f

	return mmRemoveOrder
}

// Return sets up results that will be returned by UsersRepository.RemoveOrder
func (mmRemoveOrder *mUsersRepositoryMockRemoveOrder) Return(err error) *UsersRepositoryMock {
	if mmRemoveOrder.mock.funcRemoveOrder != nil {
		mmRemoveOrder.mock.t.Fatalf("UsersRepositoryMock.RemoveOrder mock is already set by Set")
	}

	if mmRemoveOrder.defaultExpectation == nil {
		mmRemoveOrder.defaultExpectation = &UsersRepositoryMockRemoveOrderExpectation{mock: mmRemoveOrder.mock}
	}
	mmRemoveOrder.defaultExpectation.results = &UsersRepositoryMockRemoveOrderResults{err}
	mmRemoveOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRemoveOrder.mock
}

// Set uses given function f to mock the UsersRepository.RemoveOrder method
func (mmRemoveOrder *mUsersRepositoryMockRemoveOrder) Set(f func(userID uint64, orderID uint64) (err error)) *UsersRepositoryMock {
	if mmRemoveOrder.defaultExpectation != nil {
		mmRemoveOrder.mock.t.Fatalf("Default expectation is already set for the UsersRepository.RemoveOrder method")
	}

	if len(mmRemoveOrder.expectations) > 0 {
		mmRemoveOrder.mock.t.Fatalf("Some expectations are already set for the UsersRepository.RemoveOrder method")
	}

	mmRemoveOrder.mock.funcRemoveOrder = f
	mmRemoveOrder.mock.funcRemoveOrderOrigin = minimock.CallerInfo(1)
	return mmRemoveOrder.mock
}

// When sets expectation for the UsersRepository.RemoveOrder which will trigger the result defined by the following
// Then helper
func (mmRemoveOrder *mUsersRepositoryMockRemoveOrder) When(userID uint64, orderID uint64) *UsersRepositoryMockRemoveOrderExpectation {
	if mmRemoveOrder.mock.funcRemoveOrder != nil {
		mmRemoveOrder.mock.t.Fatalf("UsersRepositoryMock.RemoveOrder mock is already set by Set")
	}

	expectation := &UsersRepositoryMockRemoveOrderExpectation{
		mock:               mmRemoveOrder.mock,
		params:             &UsersRepositoryMockRemoveOrderParams{userID, orderID},
		expectationOrigins: UsersRepositoryMockRemoveOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRemoveOrder.expectations = append(mmRemoveOrder.expectations, expectation)
	return expectation
}

// Then sets up UsersRepository.RemoveOrder return parameters for the expectation previously defined by the When method
func (e *UsersRepositoryMockRemoveOrderExpectation) Then(err error) *UsersRepositoryMock {
	e.results = &UsersRepositoryMockRemoveOrderResults{err}
	return e.mock
}

// Times sets number of times UsersRepository.RemoveOrder should be invoked
func (mmRemoveOrder *mUsersRepositoryMockRemoveOrder) Times(n uint64) *mUsersRepositoryMockRemoveOrder {
	if n == 0 {
		mmRemoveOrder.mock.t.Fatalf("Times of UsersRepositoryMock.RemoveOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemoveOrder.expectedInvocations, n)
	mmRemoveOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRemoveOrder
}

func (mmRemoveOrder *mUsersRepositoryMockRemoveOrder) invocationsDone() bool {
	if len(mmRemoveOrder.expectations) == 0 && mmRemoveOrder.defaultExpectation == nil && mmRemoveOrder.mock.funcRemoveOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemoveOrder.mock.afterRemoveOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemoveOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RemoveOrder implements mm_storage.UsersRepository
func (mmRemoveOrder *UsersRepositoryMock) RemoveOrder(userID uint64, orderID uint64) (err error) {
	mm_atomic.AddUint64(&mmRemoveOrder.beforeRemoveOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveOrder.afterRemoveOrderCounter, 1)

	mmRemoveOrder.t.Helper()

	if mmRemoveOrder.inspectFuncRemoveOrder != nil {
		mmRemoveOrder.inspectFuncRemoveOrder(userID, orderID)
	}

	mm_params := UsersRepositoryMockRemoveOrderParams{userID, orderID}

	// Record call args
	mmRemoveOrder.RemoveOrderMock.mutex.Lock()
	mmRemoveOrder.RemoveOrderMock.callArgs = append(mmRemoveOrder.RemoveOrderMock.callArgs, &mm_params)
	mmRemoveOrder.RemoveOrderMock.mutex.Unlock()

	for _, e := range mmRemoveOrder.RemoveOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRemoveOrder.RemoveOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveOrder.RemoveOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveOrder.RemoveOrderMock.defaultExpectation.params
		mm_want_ptrs := mmRemoveOrder.RemoveOrderMock.defaultExpectation.paramPtrs

		mm_got := UsersRepositoryMockRemoveOrderParams{userID, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmRemoveOrder.t.Errorf("UsersRepositoryMock.RemoveOrder got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveOrder.RemoveOrderMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmRemoveOrder.t.Errorf("UsersRepositoryMock.RemoveOrder got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveOrder.RemoveOrderMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveOrder.t.Errorf("UsersRepositoryMock.RemoveOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRemoveOrder.RemoveOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveOrder.RemoveOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveOrder.t.Fatal("No results are set for the UsersRepositoryMock.RemoveOrder")
		}
		return (*mm_results).err
	}
	if mmRemoveOrder.funcRemoveOrder != nil {
		return mmRemoveOrder.funcRemoveOrder(userID, orderID)
	}
	mmRemoveOrder.t.Fatalf("Unexpected call to UsersRepositoryMock.RemoveOrder. %v %v", userID, orderID)
	return
}

// RemoveOrderAfterCounter returns a count of finished UsersRepositoryMock.RemoveOrder invocations
func (mmRemoveOrder *UsersRepositoryMock) RemoveOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveOrder.afterRemoveOrderCounter)
}

// RemoveOrderBeforeCounter returns a count of UsersRepositoryMock.RemoveOrder invocations
func (mmRemoveOrder *UsersRepositoryMock) RemoveOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveOrder.beforeRemoveOrderCounter)
}

// Calls returns a list of arguments used in each call to UsersRepositoryMock.RemoveOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveOrder *mUsersRepositoryMockRemoveOrder) Calls() []*UsersRepositoryMockRemoveOrderParams {
	mmRemoveOrder.mutex.RLock()

	argCopy := make([]*UsersRepositoryMockRemoveOrderParams, len(mmRemoveOrder.callArgs))
	copy(argCopy, mmRemoveOrder.callArgs)

	mmRemoveOrder.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveOrderDone returns true if the count of the RemoveOrder invocations corresponds
// the number of defined expectations
func (m *UsersRepositoryMock) MinimockRemoveOrderDone() bool {
	if m.RemoveOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemoveOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemoveOrderMock.invocationsDone()
}

// MinimockRemoveOrderInspect logs each unmet expectation
func (m *UsersRepositoryMock) MinimockRemoveOrderInspect() {
	for _, e := range m.RemoveOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UsersRepositoryMock.RemoveOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRemoveOrderCounter := mm_atomic.LoadUint64(&m.afterRemoveOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveOrderMock.defaultExpectation != nil && afterRemoveOrderCounter < 1 {
		if m.RemoveOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UsersRepositoryMock.RemoveOrder at\n%s", m.RemoveOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UsersRepositoryMock.RemoveOrder at\n%s with params: %#v", m.RemoveOrderMock.defaultExpectation.expectationOrigins.origin, *m.RemoveOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveOrder != nil && afterRemoveOrderCounter < 1 {
		m.t.Errorf("Expected call to UsersRepositoryMock.RemoveOrder at\n%s", m.funcRemoveOrderOrigin)
	}

	if !m.RemoveOrderMock.invocationsDone() && afterRemoveOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to UsersRepositoryMock.RemoveOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RemoveOrderMock.expectedInvocations), m.RemoveOrderMock.expectedInvocationsOrigin, afterRemoveOrderCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UsersRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddOrderInspect()

			m.MinimockCanRemoveInspect()

			m.MinimockGetExpirationDateInspect()

			m.MinimockGetOrderInspect()

			m.MinimockGetOrdersInspect()

			m.MinimockRemoveOrderInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UsersRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UsersRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddOrderDone() &&
		m.MinimockCanRemoveDone() &&
		m.MinimockGetExpirationDateDone() &&
		m.MinimockGetOrderDone() &&
		m.MinimockGetOrdersDone() &&
		m.MinimockRemoveOrderDone()
}
